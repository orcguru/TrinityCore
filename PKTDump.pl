#!/usr/bin/perl
use warnings;
use strict;
use Math::BigInt;

if ($#ARGV < 0) {
  print "Usage: ./PKTDump.pl <WOW pkt file>\n";
  exit 1;
}

my %type_parser = (
"char" => \&type_char, "uint8" => \&type_uint8, "uint16" => \&type_uint16, "uint32" => \&type_uint32,
);

my %type_size = (
"char" => 1, "uint8" => 1, "uint16" => 2, "uint32" => 4,
);

my %correction = (
"Direction" => \&correct_direction, "Opcode" => \&decode_opcode,
);

my %opcode = (
0x001 => "CMSG_BOOTME", 0x002 => "CMSG_DBLOOKUP", 0x003 => "SMSG_DBLOOKUP", 0x004 => "CMSG_QUERY_OBJECT_POSITION", 0x005 => "SMSG_QUERY_OBJECT_POSITION", 0x006 => "CMSG_QUERY_OBJECT_ROTATION", 0x007 => "SMSG_QUERY_OBJECT_ROTATION", 0x008 => "CMSG_WORLD_TELEPORT", 0x009 => "CMSG_TELEPORT_TO_UNIT", 0x00A => "CMSG_ZONE_MAP", 0x00B => "SMSG_ZONE_MAP", 0x00C => "CMSG_DEBUG_CHANGECELLZONE", 0x00D => "CMSG_MOVE_CHARACTER_CHEAT", 0x00E => "SMSG_MOVE_CHARACTER_CHEAT", 0x00F => "CMSG_RECHARGE", 0x010 => "CMSG_LEARN_SPELL", 0x011 => "CMSG_CREATEMONSTER", 0x012 => "CMSG_DESTROYMONSTER", 0x013 => "CMSG_CREATEITEM", 0x014 => "CMSG_CREATEGAMEOBJECT", 0x015 => "SMSG_CHECK_FOR_BOTS", 0x016 => "CMSG_MAKEMONSTERATTACKGUID", 0x017 => "CMSG_BOT_DETECTED2", 0x018 => "CMSG_FORCEACTION", 0x019 => "CMSG_FORCEACTIONONOTHER", 0x01A => "CMSG_FORCEACTIONSHOW", 0x01B => "SMSG_FORCEACTIONSHOW", 0x01C => "CMSG_PETGODMODE", 0x01D => "SMSG_PETGODMODE", 0x01E => "SMSG_REFER_A_FRIEND_EXPIRED", 0x01F => "CMSG_WEATHER_SPEED_CHEAT", 0x020 => "CMSG_UNDRESSPLAYER", 0x021 => "CMSG_BEASTMASTER", 0x022 => "CMSG_GODMODE", 0x023 => "SMSG_GODMODE", 0x024 => "CMSG_CHEAT_SETMONEY", 0x025 => "CMSG_LEVEL_CHEAT", 0x026 => "CMSG_PET_LEVEL_CHEAT", 0x027 => "CMSG_SET_WORLDSTATE", 0x028 => "CMSG_COOLDOWN_CHEAT", 0x029 => "CMSG_USE_SKILL_CHEAT", 0x02A => "CMSG_FLAG_QUEST", 0x02B => "CMSG_FLAG_QUEST_FINISH", 0x02C => "CMSG_CLEAR_QUEST", 0x02D => "CMSG_SEND_EVENT", 0x02E => "CMSG_DEBUG_AISTATE", 0x02F => "SMSG_DEBUG_AISTATE", 0x030 => "CMSG_DISABLE_PVP_CHEAT", 0x031 => "CMSG_ADVANCE_SPAWN_TIME", 0x032 => "SMSG_DESTRUCTIBLE_BUILDING_DAMAGE", 0x033 => "CMSG_AUTH_SRP6_BEGIN", 0x034 => "CMSG_AUTH_SRP6_PROOF", 0x035 => "CMSG_AUTH_SRP6_RECODE", 0x036 => "CMSG_CHAR_CREATE", 0x037 => "CMSG_CHAR_ENUM", 0x038 => "CMSG_CHAR_DELETE", 0x039 => "SMSG_AUTH_SRP6_RESPONSE", 0x03A => "SMSG_CHAR_CREATE", 0x03B => "SMSG_CHAR_ENUM", 0x03C => "SMSG_CHAR_DELETE", 0x03D => "CMSG_PLAYER_LOGIN", 0x03E => "SMSG_NEW_WORLD", 0x03F => "SMSG_TRANSFER_PENDING", 0x040 => "SMSG_TRANSFER_ABORTED", 0x041 => "SMSG_CHARACTER_LOGIN_FAILED", 0x042 => "SMSG_LOGIN_SET_TIME_SPEED", 0x043 => "SMSG_GAMETIME_UPDATE", 0x044 => "CMSG_GAMETIME_SET", 0x045 => "SMSG_GAMETIME_SET", 0x046 => "CMSG_GAMESPEED_SET", 0x047 => "SMSG_GAMESPEED_SET", 0x048 => "CMSG_SERVERTIME", 0x049 => "SMSG_SERVERTIME", 0x04A => "CMSG_PLAYER_LOGOUT", 0x04B => "CMSG_LOGOUT_REQUEST", 0x04C => "SMSG_LOGOUT_RESPONSE", 0x04D => "SMSG_LOGOUT_COMPLETE", 0x04E => "CMSG_LOGOUT_CANCEL", 0x04F => "SMSG_LOGOUT_CANCEL_ACK", 0x050 => "CMSG_NAME_QUERY", 0x051 => "SMSG_NAME_QUERY_RESPONSE", 0x052 => "CMSG_PET_NAME_QUERY", 0x053 => "SMSG_PET_NAME_QUERY_RESPONSE", 0x054 => "CMSG_GUILD_QUERY", 0x055 => "SMSG_GUILD_QUERY_RESPONSE", 0x056 => "CMSG_ITEM_QUERY_SINGLE", 0x057 => "CMSG_ITEM_QUERY_MULTIPLE", 0x058 => "SMSG_ITEM_QUERY_SINGLE_RESPONSE", 0x059 => "SMSG_ITEM_QUERY_MULTIPLE_RESPONSE", 0x05A => "CMSG_PAGE_TEXT_QUERY", 0x05B => "SMSG_PAGE_TEXT_QUERY_RESPONSE", 0x05C => "CMSG_QUEST_QUERY", 0x05D => "SMSG_QUEST_QUERY_RESPONSE", 0x05E => "CMSG_GAMEOBJECT_QUERY", 0x05F => "SMSG_GAMEOBJECT_QUERY_RESPONSE", 0x060 => "CMSG_CREATURE_QUERY", 0x061 => "SMSG_CREATURE_QUERY_RESPONSE", 0x062 => "CMSG_WHO", 0x063 => "SMSG_WHO", 0x064 => "CMSG_WHOIS", 0x065 => "SMSG_WHOIS", 0x066 => "CMSG_CONTACT_LIST", 0x067 => "SMSG_CONTACT_LIST", 0x068 => "SMSG_FRIEND_STATUS", 0x069 => "CMSG_ADD_FRIEND", 0x06A => "CMSG_DEL_FRIEND", 0x06B => "CMSG_SET_CONTACT_NOTES", 0x06C => "CMSG_ADD_IGNORE", 0x06D => "CMSG_DEL_IGNORE", 0x06E => "CMSG_GROUP_INVITE", 0x06F => "SMSG_GROUP_INVITE", 0x070 => "CMSG_GROUP_CANCEL", 0x071 => "SMSG_GROUP_CANCEL", 0x072 => "CMSG_GROUP_ACCEPT", 0x073 => "CMSG_GROUP_DECLINE", 0x074 => "SMSG_GROUP_DECLINE", 0x075 => "CMSG_GROUP_UNINVITE", 0x076 => "CMSG_GROUP_UNINVITE_GUID", 0x077 => "SMSG_GROUP_UNINVITE", 0x078 => "CMSG_GROUP_SET_LEADER", 0x079 => "SMSG_GROUP_SET_LEADER", 0x07A => "CMSG_LOOT_METHOD", 0x07B => "CMSG_GROUP_DISBAND", 0x07C => "SMSG_GROUP_DESTROYED", 0x07D => "SMSG_GROUP_LIST", 0x07E => "SMSG_PARTY_MEMBER_STATS", 0x07F => "SMSG_PARTY_COMMAND_RESULT", 0x080 => "UMSG_UPDATE_GROUP_MEMBERS", 0x081 => "CMSG_GUILD_CREATE", 0x082 => "CMSG_GUILD_INVITE", 0x083 => "SMSG_GUILD_INVITE", 0x084 => "CMSG_GUILD_ACCEPT", 0x085 => "CMSG_GUILD_DECLINE", 0x086 => "SMSG_GUILD_DECLINE", 0x087 => "CMSG_GUILD_INFO", 0x088 => "SMSG_GUILD_INFO", 0x089 => "CMSG_GUILD_ROSTER", 0x08A => "SMSG_GUILD_ROSTER", 0x08B => "CMSG_GUILD_PROMOTE", 0x08C => "CMSG_GUILD_DEMOTE", 0x08D => "CMSG_GUILD_LEAVE", 0x08E => "CMSG_GUILD_REMOVE", 0x08F => "CMSG_GUILD_DISBAND", 0x090 => "CMSG_GUILD_LEADER", 0x091 => "CMSG_GUILD_MOTD", 0x092 => "SMSG_GUILD_EVENT", 0x093 => "SMSG_GUILD_COMMAND_RESULT", 0x094 => "UMSG_UPDATE_GUILD", 0x095 => "CMSG_MESSAGECHAT", 0x096 => "SMSG_MESSAGECHAT", 0x097 => "CMSG_JOIN_CHANNEL", 0x098 => "CMSG_LEAVE_CHANNEL", 0x099 => "SMSG_CHANNEL_NOTIFY", 0x09A => "CMSG_CHANNEL_LIST", 0x09B => "SMSG_CHANNEL_LIST", 0x09C => "CMSG_CHANNEL_PASSWORD", 0x09D => "CMSG_CHANNEL_SET_OWNER", 0x09E => "CMSG_CHANNEL_OWNER", 0x09F => "CMSG_CHANNEL_MODERATOR", 0x0A0 => "CMSG_CHANNEL_UNMODERATOR", 0x0A1 => "CMSG_CHANNEL_MUTE", 0x0A2 => "CMSG_CHANNEL_UNMUTE", 0x0A3 => "CMSG_CHANNEL_INVITE", 0x0A4 => "CMSG_CHANNEL_KICK", 0x0A5 => "CMSG_CHANNEL_BAN", 0x0A6 => "CMSG_CHANNEL_UNBAN", 0x0A7 => "CMSG_CHANNEL_ANNOUNCEMENTS", 0x0A8 => "CMSG_CHANNEL_MODERATE", 0x0A9 => "SMSG_UPDATE_OBJECT", 0x0AA => "SMSG_DESTROY_OBJECT", 0x0AB => "CMSG_USE_ITEM", 0x0AC => "CMSG_OPEN_ITEM", 0x0AD => "CMSG_READ_ITEM", 0x0AE => "SMSG_READ_ITEM_OK", 0x0AF => "SMSG_READ_ITEM_FAILED", 0x0B0 => "SMSG_ITEM_COOLDOWN", 0x0B1 => "CMSG_GAMEOBJ_USE", 0x0B2 => "CMSG_DESTROY_ITEMS", 0x0B3 => "SMSG_GAMEOBJECT_CUSTOM_ANIM", 0x0B4 => "CMSG_AREATRIGGER", 0x0B5 => "MSG_MOVE_START_FORWARD", 0x0B6 => "MSG_MOVE_START_BACKWARD", 0x0B7 => "MSG_MOVE_STOP", 0x0B8 => "MSG_MOVE_START_STRAFE_LEFT", 0x0B9 => "MSG_MOVE_START_STRAFE_RIGHT", 0x0BA => "MSG_MOVE_STOP_STRAFE", 0x0BB => "MSG_MOVE_JUMP", 0x0BC => "MSG_MOVE_START_TURN_LEFT", 0x0BD => "MSG_MOVE_START_TURN_RIGHT", 0x0BE => "MSG_MOVE_STOP_TURN", 0x0BF => "MSG_MOVE_START_PITCH_UP", 0x0C0 => "MSG_MOVE_START_PITCH_DOWN", 0x0C1 => "MSG_MOVE_STOP_PITCH", 0x0C2 => "MSG_MOVE_SET_RUN_MODE", 0x0C3 => "MSG_MOVE_SET_WALK_MODE", 0x0C4 => "MSG_MOVE_TOGGLE_LOGGING", 0x0C5 => "MSG_MOVE_TELEPORT", 0x0C6 => "MSG_MOVE_TELEPORT_CHEAT", 0x0C7 => "MSG_MOVE_TELEPORT_ACK", 0x0C8 => "MSG_MOVE_TOGGLE_FALL_LOGGING", 0x0C9 => "MSG_MOVE_FALL_LAND", 0x0CA => "MSG_MOVE_START_SWIM", 0x0CB => "MSG_MOVE_STOP_SWIM", 0x0CC => "MSG_MOVE_SET_RUN_SPEED_CHEAT", 0x0CD => "MSG_MOVE_SET_RUN_SPEED", 0x0CE => "MSG_MOVE_SET_RUN_BACK_SPEED_CHEAT", 0x0CF => "MSG_MOVE_SET_RUN_BACK_SPEED", 0x0D0 => "MSG_MOVE_SET_WALK_SPEED_CHEAT", 0x0D1 => "MSG_MOVE_SET_WALK_SPEED", 0x0D2 => "MSG_MOVE_SET_SWIM_SPEED_CHEAT", 0x0D3 => "MSG_MOVE_SET_SWIM_SPEED", 0x0D4 => "MSG_MOVE_SET_SWIM_BACK_SPEED_CHEAT", 0x0D5 => "MSG_MOVE_SET_SWIM_BACK_SPEED", 0x0D6 => "MSG_MOVE_SET_ALL_SPEED_CHEAT", 0x0D7 => "MSG_MOVE_SET_TURN_RATE_CHEAT", 0x0D8 => "MSG_MOVE_SET_TURN_RATE", 0x0D9 => "MSG_MOVE_TOGGLE_COLLISION_CHEAT", 0x0DA => "MSG_MOVE_SET_FACING", 0x0DB => "MSG_MOVE_SET_PITCH", 0x0DC => "MSG_MOVE_WORLDPORT_ACK", 0x0DD => "SMSG_MONSTER_MOVE", 0x0DE => "SMSG_MOVE_WATER_WALK", 0x0DF => "SMSG_MOVE_LAND_WALK", 0x0E0 => "CMSG_MOVE_CHARM_PORT_CHEAT", 0x0E1 => "CMSG_MOVE_SET_RAW_POSITION", 0x0E2 => "SMSG_FORCE_RUN_SPEED_CHANGE", 0x0E3 => "CMSG_FORCE_RUN_SPEED_CHANGE_ACK", 0x0E4 => "SMSG_FORCE_RUN_BACK_SPEED_CHANGE", 0x0E5 => "CMSG_FORCE_RUN_BACK_SPEED_CHANGE_ACK", 0x0E6 => "SMSG_FORCE_SWIM_SPEED_CHANGE", 0x0E7 => "CMSG_FORCE_SWIM_SPEED_CHANGE_ACK", 0x0E8 => "SMSG_FORCE_MOVE_ROOT", 0x0E9 => "CMSG_FORCE_MOVE_ROOT_ACK", 0x0EA => "SMSG_FORCE_MOVE_UNROOT", 0x0EB => "CMSG_FORCE_MOVE_UNROOT_ACK", 0x0EC => "MSG_MOVE_ROOT", 0x0ED => "MSG_MOVE_UNROOT", 0x0EE => "MSG_MOVE_HEARTBEAT", 0x0EF => "SMSG_MOVE_KNOCK_BACK", 0x0F0 => "CMSG_MOVE_KNOCK_BACK_ACK", 0x0F1 => "MSG_MOVE_KNOCK_BACK", 0x0F2 => "SMSG_MOVE_FEATHER_FALL", 0x0F3 => "SMSG_MOVE_NORMAL_FALL", 0x0F4 => "SMSG_MOVE_SET_HOVER", 0x0F5 => "SMSG_MOVE_UNSET_HOVER", 0x0F6 => "CMSG_MOVE_HOVER_ACK", 0x0F7 => "MSG_MOVE_HOVER", 0x0F8 => "CMSG_TRIGGER_CINEMATIC_CHEAT", 0x0F9 => "CMSG_OPENING_CINEMATIC", 0x0FA => "SMSG_TRIGGER_CINEMATIC", 0x0FB => "CMSG_NEXT_CINEMATIC_CAMERA", 0x0FC => "CMSG_COMPLETE_CINEMATIC", 0x0FD => "SMSG_TUTORIAL_FLAGS", 0x0FE => "CMSG_TUTORIAL_FLAG", 0x0FF => "CMSG_TUTORIAL_CLEAR", 0x100 => "CMSG_TUTORIAL_RESET", 0x101 => "CMSG_STANDSTATECHANGE", 0x102 => "CMSG_EMOTE", 0x103 => "SMSG_EMOTE", 0x104 => "CMSG_TEXT_EMOTE", 0x105 => "SMSG_TEXT_EMOTE", 0x106 => "CMSG_AUTOEQUIP_GROUND_ITEM", 0x107 => "CMSG_AUTOSTORE_GROUND_ITEM", 0x108 => "CMSG_AUTOSTORE_LOOT_ITEM", 0x109 => "CMSG_STORE_LOOT_IN_SLOT", 0x10A => "CMSG_AUTOEQUIP_ITEM", 0x10B => "CMSG_AUTOSTORE_BAG_ITEM", 0x10C => "CMSG_SWAP_ITEM", 0x10D => "CMSG_SWAP_INV_ITEM", 0x10E => "CMSG_SPLIT_ITEM", 0x10F => "CMSG_AUTOEQUIP_ITEM_SLOT", 0x110 => "CMSG_UNCLAIM_LICENSE", 0x111 => "CMSG_DESTROYITEM", 0x112 => "SMSG_INVENTORY_CHANGE_FAILURE", 0x113 => "SMSG_OPEN_CONTAINER", 0x114 => "CMSG_INSPECT", 0x115 => "SMSG_INSPECT_RESULTS_UPDATE", 0x116 => "CMSG_INITIATE_TRADE", 0x117 => "CMSG_BEGIN_TRADE", 0x118 => "CMSG_BUSY_TRADE", 0x119 => "CMSG_IGNORE_TRADE", 0x11A => "CMSG_ACCEPT_TRADE", 0x11B => "CMSG_UNACCEPT_TRADE", 0x11C => "CMSG_CANCEL_TRADE", 0x11D => "CMSG_SET_TRADE_ITEM", 0x11E => "CMSG_CLEAR_TRADE_ITEM", 0x11F => "CMSG_SET_TRADE_GOLD", 0x120 => "SMSG_TRADE_STATUS", 0x121 => "SMSG_TRADE_STATUS_EXTENDED", 0x122 => "SMSG_INITIALIZE_FACTIONS", 0x123 => "SMSG_SET_FACTION_VISIBLE", 0x124 => "SMSG_SET_FACTION_STANDING", 0x125 => "CMSG_SET_FACTION_ATWAR", 0x126 => "CMSG_SET_FACTION_CHEAT", 0x127 => "SMSG_SET_PROFICIENCY", 0x128 => "CMSG_SET_ACTION_BUTTON", 0x129 => "SMSG_ACTION_BUTTONS", 0x12A => "SMSG_INITIAL_SPELLS", 0x12B => "SMSG_LEARNED_SPELL", 0x12C => "SMSG_SUPERCEDED_SPELL", 0x12D => "CMSG_NEW_SPELL_SLOT", 0x12E => "CMSG_CAST_SPELL", 0x12F => "CMSG_CANCEL_CAST", 0x130 => "SMSG_CAST_FAILED", 0x131 => "SMSG_SPELL_START", 0x132 => "SMSG_SPELL_GO", 0x133 => "SMSG_SPELL_FAILURE", 0x134 => "SMSG_SPELL_COOLDOWN", 0x135 => "SMSG_COOLDOWN_EVENT", 0x136 => "CMSG_CANCEL_AURA", 0x137 => "SMSG_EQUIPMENT_SET_SAVED", 0x138 => "SMSG_PET_CAST_FAILED", 0x139 => "MSG_CHANNEL_START", 0x13A => "MSG_CHANNEL_UPDATE", 0x13B => "CMSG_CANCEL_CHANNELLING", 0x13C => "SMSG_AI_REACTION", 0x13D => "CMSG_SET_SELECTION", 0x13E => "CMSG_DELETEEQUIPMENT_SET", 0x13F => "CMSG_INSTANCE_LOCK_RESPONSE", 0x140 => "CMSG_DEBUG_PASSIVE_AURA", 0x141 => "CMSG_ATTACK_SWING", 0x142 => "CMSG_ATTACK_STOP", 0x143 => "SMSG_ATTACK_START", 0x144 => "SMSG_ATTACK_STOP", 0x145 => "SMSG_ATTACK_SWING_NOT_IN_RANGE", 0x146 => "SMSG_ATTACK_SWING_BAD_FACING", 0x147 => "SMSG_INSTANCE_LOCK_WARNING_QUERY", 0x148 => "SMSG_ATTACK_SWING_DEAD_TARGET", 0x149 => "SMSG_ATTACK_SWING_CANT_ATTACK", 0x14A => "SMSG_ATTACKERSTATEUPDATE", 0x14B => "SMSG_BATTLEFIELD_PORT_DENIED", 0x14C => "CMSG_PERFORM_ACTION_SET", 0x14D => "SMSG_RESUME_CAST_BAR", 0x14E => "SMSG_CANCEL_COMBAT", 0x14F => "SMSG_SPELLBREAKLOG", 0x150 => "SMSG_SPELLHEALLOG", 0x151 => "SMSG_SPELLENERGIZELOG", 0x152 => "SMSG_BREAK_TARGET", 0x153 => "CMSG_SAVE_PLAYER", 0x154 => "CMSG_SETDEATHBINDPOINT", 0x155 => "SMSG_BIND_POINT_UPDATE", 0x156 => "CMSG_GETDEATHBINDZONE", 0x157 => "SMSG_BINDZONEREPLY", 0x158 => "SMSG_PLAYER_BOUND", 0x159 => "SMSG_CLIENT_CONTROL_UPDATE", 0x15A => "CMSG_REPOP_REQUEST", 0x15B => "SMSG_RESURRECT_REQUEST", 0x15C => "CMSG_RESURRECT_RESPONSE", 0x15D => "CMSG_LOOT", 0x15E => "CMSG_LOOT_MONEY", 0x15F => "CMSG_LOOT_RELEASE", 0x160 => "SMSG_LOOT_RESPONSE", 0x161 => "SMSG_LOOT_RELEASE_RESPONSE", 0x162 => "SMSG_LOOT_REMOVED", 0x163 => "SMSG_LOOT_MONEY_NOTIFY", 0x164 => "SMSG_LOOT_ITEM_NOTIFY", 0x165 => "SMSG_LOOT_CLEAR_MONEY", 0x166 => "SMSG_ITEM_PUSH_RESULT", 0x167 => "SMSG_DUEL_REQUESTED", 0x168 => "SMSG_DUEL_OUTOFBOUNDS", 0x169 => "SMSG_DUEL_INBOUNDS", 0x16A => "SMSG_DUEL_COMPLETE", 0x16B => "SMSG_DUEL_WINNER", 0x16C => "CMSG_DUEL_ACCEPTED", 0x16D => "CMSG_DUEL_CANCELLED", 0x16E => "SMSG_MOUNT_RESULT", 0x16F => "SMSG_DISMOUNTRESULT", 0x170 => "SMSG_REMOVED_FROM_PVP_QUEUE", 0x171 => "CMSG_MOUNTSPECIAL_ANIM", 0x172 => "SMSG_MOUNTSPECIAL_ANIM", 0x173 => "SMSG_PET_TAME_FAILURE", 0x174 => "CMSG_PET_SET_ACTION", 0x175 => "CMSG_PET_ACTION", 0x176 => "CMSG_PET_ABANDON", 0x177 => "CMSG_PET_RENAME", 0x178 => "SMSG_PET_NAME_INVALID", 0x179 => "SMSG_PET_SPELLS", 0x17A => "SMSG_PET_MODE", 0x17B => "CMSG_GOSSIP_HELLO", 0x17C => "CMSG_GOSSIP_SELECT_OPTION", 0x17D => "SMSG_GOSSIP_MESSAGE", 0x17E => "SMSG_GOSSIP_COMPLETE", 0x17F => "CMSG_NPC_TEXT_QUERY", 0x180 => "SMSG_NPC_TEXT_UPDATE", 0x181 => "SMSG_NPC_WONT_TALK", 0x182 => "CMSG_QUESTGIVER_STATUS_QUERY", 0x183 => "SMSG_QUESTGIVER_STATUS", 0x184 => "CMSG_QUESTGIVER_HELLO", 0x185 => "SMSG_QUESTGIVER_QUEST_LIST", 0x186 => "CMSG_QUESTGIVER_QUERY_QUEST", 0x187 => "CMSG_QUESTGIVER_QUEST_AUTOLAUNCH", 0x188 => "SMSG_QUEST_GIVER_QUEST_DETAILS", 0x189 => "CMSG_QUESTGIVER_ACCEPT_QUEST", 0x18A => "CMSG_QUESTGIVER_COMPLETE_QUEST", 0x18B => "SMSG_QUESTGIVER_REQUEST_ITEMS", 0x18C => "CMSG_QUESTGIVER_REQUEST_REWARD", 0x18D => "SMSG_QUEST_GIVER_OFFER_REWARD_MESSAGE", 0x18E => "CMSG_QUESTGIVER_CHOOSE_REWARD", 0x18F => "SMSG_QUESTGIVER_QUEST_INVALID", 0x190 => "CMSG_QUESTGIVER_CANCEL", 0x191 => "SMSG_QUESTGIVER_QUEST_COMPLETE", 0x192 => "SMSG_QUESTGIVER_QUEST_FAILED", 0x193 => "CMSG_QUESTLOG_SWAP_QUEST", 0x194 => "CMSG_QUESTLOG_REMOVE_QUEST", 0x195 => "SMSG_QUESTLOG_FULL", 0x196 => "SMSG_QUESTUPDATE_FAILED", 0x197 => "SMSG_QUESTUPDATE_FAILEDTIMER", 0x198 => "SMSG_QUESTUPDATE_COMPLETE", 0x199 => "SMSG_QUESTUPDATE_ADD_KILL", 0x19A => "SMSG_QUESTUPDATE_ADD_ITEM", 0x19B => "CMSG_QUEST_CONFIRM_ACCEPT", 0x19C => "SMSG_QUEST_CONFIRM_ACCEPT", 0x19D => "CMSG_PUSHQUESTTOPARTY", 0x19E => "CMSG_LIST_INVENTORY", 0x19F => "SMSG_LIST_INVENTORY", 0x1A0 => "CMSG_SELL_ITEM", 0x1A1 => "SMSG_SELL_ITEM", 0x1A2 => "CMSG_BUY_ITEM", 0x1A3 => "CMSG_BUY_ITEM_IN_SLOT", 0x1A4 => "SMSG_BUY_ITEM", 0x1A5 => "SMSG_BUY_FAILED", 0x1A6 => "CMSG_TAXICLEARALLNODES", 0x1A7 => "CMSG_TAXIENABLEALLNODES", 0x1A8 => "CMSG_TAXISHOWNODES", 0x1A9 => "SMSG_SHOWTAXINODES", 0x1AA => "CMSG_TAXINODE_STATUS_QUERY", 0x1AB => "SMSG_TAXINODE_STATUS", 0x1AC => "CMSG_TAXIQUERYAVAILABLENODES", 0x1AD => "CMSG_ACTIVATETAXI", 0x1AE => "SMSG_ACTIVATETAXIREPLY", 0x1AF => "SMSG_NEW_TAXI_PATH", 0x1B0 => "CMSG_TRAINER_LIST", 0x1B1 => "SMSG_TRAINER_LIST", 0x1B2 => "CMSG_TRAINER_BUY_SPELL", 0x1B3 => "SMSG_TRAINER_BUY_SUCCEEDED", 0x1B4 => "SMSG_TRAINER_BUY_FAILED", 0x1B5 => "CMSG_BINDER_ACTIVATE", 0x1B6 => "SMSG_PLAYERBINDERROR", 0x1B7 => "CMSG_BANKER_ACTIVATE", 0x1B8 => "SMSG_SHOW_BANK", 0x1B9 => "CMSG_BUY_BANK_SLOT", 0x1BA => "SMSG_BUY_BANK_SLOT_RESULT", 0x1BB => "CMSG_PETITION_SHOWLIST", 0x1BC => "SMSG_PETITION_SHOWLIST", 0x1BD => "CMSG_PETITION_BUY", 0x1BE => "CMSG_PETITION_SHOW_SIGNATURES", 0x1BF => "SMSG_PETITION_SHOW_SIGNATURES", 0x1C0 => "CMSG_PETITION_SIGN", 0x1C1 => "SMSG_PETITION_SIGN_RESULTS", 0x1C2 => "MSG_PETITION_DECLINE", 0x1C3 => "CMSG_OFFER_PETITION", 0x1C4 => "CMSG_TURN_IN_PETITION", 0x1C5 => "SMSG_TURN_IN_PETITION_RESULTS", 0x1C6 => "CMSG_PETITION_QUERY", 0x1C7 => "SMSG_PETITION_QUERY_RESPONSE", 0x1C8 => "SMSG_FISH_NOT_HOOKED", 0x1C9 => "SMSG_FISH_ESCAPED", 0x1CA => "CMSG_BUG", 0x1CB => "SMSG_NOTIFICATION", 0x1CC => "CMSG_PLAYED_TIME", 0x1CD => "SMSG_PLAYED_TIME", 0x1CE => "CMSG_QUERY_TIME", 0x1CF => "SMSG_QUERY_TIME_RESPONSE", 0x1D0 => "SMSG_LOG_XPGAIN", 0x1D1 => "SMSG_AURACASTLOG", 0x1D2 => "CMSG_RECLAIM_CORPSE", 0x1D3 => "CMSG_WRAP_ITEM", 0x1D4 => "SMSG_LEVELUP_INFO", 0x1D5 => "MSG_MINIMAP_PING", 0x1D6 => "SMSG_RESISTLOG", 0x1D7 => "SMSG_ENCHANTMENTLOG", 0x1D8 => "CMSG_SET_SKILL_CHEAT", 0x1D9 => "SMSG_START_MIRROR_TIMER", 0x1DA => "SMSG_PAUSE_MIRROR_TIMER", 0x1DB => "SMSG_STOP_MIRROR_TIMER", 0x1DC => "CMSG_PING", 0x1DD => "SMSG_PONG", 0x1DE => "SMSG_CLEAR_COOLDOWN", 0x1DF => "SMSG_GAMEOBJECT_PAGETEXT", 0x1E0 => "CMSG_SET_SHEATHED", 0x1E1 => "SMSG_COOLDOWN_CHEAT", 0x1E2 => "SMSG_SPELL_DELAYED", 0x1E3 => "CMSG_QUEST_POI_QUERY", 0x1E4 => "SMSG_QUEST_POI_QUERY_RESPONSE", 0x1E5 => "CMSG_GHOST", 0x1E6 => "CMSG_GM_INVIS", 0x1E7 => "SMSG_INVALID_PROMOTION_CODE", 0x1E8 => "MSG_GM_BIND_OTHER", 0x1E9 => "MSG_GM_SUMMON", 0x1EA => "SMSG_ITEM_TIME_UPDATE", 0x1EB => "SMSG_ITEM_ENCHANT_TIME_UPDATE", 0x1EC => "SMSG_AUTH_CHALLENGE", 0x1ED => "CMSG_AUTH_SESSION", 0x1EE => "SMSG_AUTH_RESPONSE", 0x1EF => "MSG_GM_SHOWLABEL", 0x1F0 => "CMSG_PET_CAST_SPELL", 0x1F1 => "MSG_SAVE_GUILD_EMBLEM", 0x1F2 => "MSG_TABARDVENDOR_ACTIVATE", 0x1F3 => "SMSG_PLAY_SPELL_VISUAL", 0x1F4 => "CMSG_ZONEUPDATE", 0x1F5 => "SMSG_PARTYKILLLOG", 0x1F6 => "SMSG_COMPRESSED_UPDATE_OBJECT", 0x1F7 => "SMSG_PLAY_SPELL_IMPACT", 0x1F8 => "SMSG_EXPLORATION_EXPERIENCE", 0x1F9 => "CMSG_GM_SET_SECURITY_GROUP", 0x1FA => "CMSG_GM_NUKE", 0x1FB => "MSG_RANDOM_ROLL", 0x1FC => "SMSG_ENVIRONMENTAL_DAMAGE_LOG", 0x1FD => "CMSG_CHANGEPLAYER_DIFFICULTY", 0x1FE => "SMSG_RWHOIS", 0x1FF => "SMSG_LFG_PLAYER_REWARD", 0x200 => "SMSG_LFG_TELEPORT_DENIED", 0x201 => "CMSG_UNLEARN_SPELL", 0x202 => "CMSG_UNLEARN_SKILL", 0x203 => "SMSG_REMOVED_SPELL", 0x204 => "CMSG_DECHARGE", 0x205 => "CMSG_GMTICKET_CREATE", 0x206 => "SMSG_GMTICKET_CREATE", 0x207 => "CMSG_GMTICKET_UPDATETEXT", 0x208 => "SMSG_GMTICKET_UPDATETEXT", 0x209 => "SMSG_ACCOUNT_DATA_TIMES", 0x20A => "CMSG_REQUEST_ACCOUNT_DATA", 0x20B => "CMSG_UPDATE_ACCOUNT_DATA", 0x20C => "SMSG_UPDATE_ACCOUNT_DATA", 0x20D => "SMSG_CLEAR_FAR_SIGHT_IMMEDIATE", 0x20E => "SMSG_CHANGEPLAYER_DIFFICULTY_RESULT", 0x20F => "CMSG_GM_TEACH", 0x210 => "CMSG_GM_CREATE_ITEM_TARGET", 0x211 => "CMSG_GMTICKET_GETTICKET", 0x212 => "SMSG_GMTICKET_GETTICKET", 0x213 => "CMSG_UNLEARN_TALENTS", 0x214 => "SMSG_UPDATE_INSTANCE_ENCOUNTER_UNIT", 0x215 => "SMSG_GAMEOBJECT_DESPAWN_ANIM", 0x216 => "MSG_CORPSE_QUERY", 0x217 => "CMSG_GMTICKET_DELETETICKET", 0x218 => "SMSG_GMTICKET_DELETETICKET", 0x219 => "SMSG_CHAT_WRONG_FACTION", 0x21A => "CMSG_GMTICKET_SYSTEMSTATUS", 0x21B => "SMSG_GMTICKET_SYSTEMSTATUS", 0x21C => "CMSG_SPIRIT_HEALER_ACTIVATE", 0x21D => "CMSG_SET_STAT_CHEAT", 0x21E => "SMSG_QUEST_FORCE_REMOVE", 0x21F => "CMSG_SKILL_BUY_STEP", 0x220 => "CMSG_SKILL_BUY_RANK", 0x221 => "CMSG_XP_CHEAT", 0x222 => "SMSG_SPIRIT_HEALER_CONFIRM", 0x223 => "CMSG_CHARACTER_POINT_CHEAT", 0x224 => "SMSG_GOSSIP_POI", 0x225 => "CMSG_CHAT_IGNORED", 0x226 => "CMSG_GM_VISION", 0x227 => "CMSG_SERVER_COMMAND", 0x228 => "CMSG_GM_SILENCE", 0x229 => "CMSG_GM_REVEALTO", 0x22A => "CMSG_GM_RESURRECT", 0x22B => "CMSG_GM_SUMMONMOB", 0x22C => "CMSG_GM_MOVECORPSE", 0x22D => "CMSG_GM_FREEZE", 0x22E => "CMSG_GM_UBERINVIS", 0x22F => "CMSG_GM_REQUEST_PLAYER_INFO", 0x230 => "SMSG_GM_PLAYER_INFO", 0x231 => "CMSG_GUILD_RANK", 0x232 => "CMSG_GUILD_ADD_RANK", 0x233 => "CMSG_GUILD_DEL_RANK", 0x234 => "CMSG_GUILD_SET_PUBLIC_NOTE", 0x235 => "CMSG_GUILD_SET_OFFICER_NOTE", 0x236 => "SMSG_LOGIN_VERIFY_WORLD", 0x237 => "CMSG_CLEAR_EXPLORATION", 0x238 => "CMSG_SEND_MAIL", 0x239 => "SMSG_SEND_MAIL_RESULT", 0x23A => "CMSG_GET_MAIL_LIST", 0x23B => "SMSG_MAIL_LIST_RESULT", 0x23C => "CMSG_BATTLEFIELD_LIST", 0x23D => "SMSG_BATTLEFIELD_LIST", 0x23E => "CMSG_BATTLEFIELD_JOIN", 0x23F => "SMSG_FORCE_SET_VEHICLE_REC_ID", 0x240 => "CMSG_SET_VEHICLE_REC_ID_ACK", 0x241 => "CMSG_TAXICLEARNODE", 0x242 => "CMSG_TAXIENABLENODE", 0x243 => "CMSG_ITEM_TEXT_QUERY", 0x244 => "SMSG_ITEM_TEXT_QUERY_RESPONSE", 0x245 => "CMSG_MAIL_TAKE_MONEY", 0x246 => "CMSG_MAIL_TAKE_ITEM", 0x247 => "CMSG_MAIL_MARK_AS_READ", 0x248 => "CMSG_MAIL_RETURN_TO_SENDER", 0x249 => "CMSG_MAIL_DELETE", 0x24A => "CMSG_MAIL_CREATE_TEXT_ITEM", 0x24B => "SMSG_SPELLLOGMISS", 0x24C => "SMSG_SPELLLOGEXECUTE", 0x24D => "SMSG_DEBUGAURAPROC", 0x24E => "SMSG_PERIODICAURALOG", 0x24F => "SMSG_SPELLDAMAGESHIELD", 0x250 => "SMSG_SPELLNONMELEEDAMAGELOG", 0x251 => "CMSG_LEARN_TALENT", 0x252 => "SMSG_RESURRECT_FAILED", 0x253 => "CMSG_TOGGLE_PVP", 0x254 => "SMSG_ZONE_UNDER_ATTACK", 0x255 => "MSG_AUCTION_HELLO", 0x256 => "CMSG_AUCTION_SELL_ITEM", 0x257 => "CMSG_AUCTION_REMOVE_ITEM", 0x258 => "CMSG_AUCTION_LIST_ITEMS", 0x259 => "CMSG_AUCTION_LIST_OWNER_ITEMS", 0x25A => "CMSG_AUCTION_PLACE_BID", 0x25B => "SMSG_AUCTION_COMMAND_RESULT", 0x25C => "SMSG_AUCTION_LIST_RESULT", 0x25D => "SMSG_AUCTION_OWNER_LIST_RESULT", 0x25E => "SMSG_AUCTION_BIDDER_NOTIFICATION", 0x25F => "SMSG_AUCTION_OWNER_NOTIFICATION", 0x260 => "SMSG_PROCRESIST", 0x261 => "SMSG_COMBAT_EVENT_FAILED", 0x262 => "SMSG_DISPEL_FAILED", 0x263 => "SMSG_SPELLORDAMAGE_IMMUNE", 0x264 => "CMSG_AUCTION_LIST_BIDDER_ITEMS", 0x265 => "SMSG_AUCTION_BIDDER_LIST_RESULT", 0x266 => "SMSG_SET_FLAT_SPELL_MODIFIER", 0x267 => "SMSG_SET_PCT_SPELL_MODIFIER", 0x268 => "CMSG_SET_AMMO", 0x269 => "SMSG_CORPSE_RECLAIM_DELAY", 0x26A => "CMSG_SET_ACTIVE_MOVER", 0x26B => "CMSG_PET_CANCEL_AURA", 0x26C => "CMSG_PLAYER_AI_CHEAT", 0x26D => "CMSG_CANCEL_AUTO_REPEAT_SPELL", 0x26E => "MSG_GM_ACCOUNT_ONLINE", 0x26F => "MSG_LIST_STABLED_PETS", 0x270 => "CMSG_STABLE_PET", 0x271 => "CMSG_UNSTABLE_PET", 0x272 => "CMSG_BUY_STABLE_SLOT", 0x273 => "SMSG_STABLE_RESULT", 0x274 => "CMSG_STABLE_REVIVE_PET", 0x275 => "CMSG_STABLE_SWAP_PET", 0x276 => "MSG_QUEST_PUSH_RESULT", 0x277 => "SMSG_PLAY_MUSIC", 0x278 => "SMSG_PLAY_OBJECT_SOUND", 0x279 => "CMSG_REQUEST_PET_INFO", 0x27A => "CMSG_FAR_SIGHT", 0x27B => "SMSG_SPELLDISPELLOG", 0x27C => "SMSG_DAMAGE_CALC_LOG", 0x27D => "CMSG_ENABLE_DAMAGE_LOG", 0x27E => "CMSG_GROUP_CHANGE_SUB_GROUP", 0x27F => "CMSG_REQUEST_PARTY_MEMBER_STATS", 0x280 => "CMSG_GROUP_SWAP_SUB_GROUP", 0x281 => "CMSG_RESET_FACTION_CHEAT", 0x282 => "CMSG_AUTOSTORE_BANK_ITEM", 0x283 => "CMSG_AUTOBANK_ITEM", 0x284 => "MSG_QUERY_NEXT_MAIL_TIME", 0x285 => "SMSG_RECEIVED_MAIL", 0x286 => "SMSG_RAID_GROUP_ONLY", 0x287 => "CMSG_SET_DURABILITY_CHEAT", 0x288 => "CMSG_SET_PVP_RANK_CHEAT", 0x289 => "CMSG_ADD_PVP_MEDAL_CHEAT", 0x28A => "CMSG_DEL_PVP_MEDAL_CHEAT", 0x28B => "CMSG_SET_PVP_TITLE", 0x28C => "SMSG_PVP_CREDIT", 0x28D => "SMSG_AUCTION_REMOVED_NOTIFICATION", 0x28E => "CMSG_GROUP_RAID_CONVERT", 0x28F => "CMSG_GROUP_ASSISTANT_LEADER", 0x290 => "CMSG_BUYBACK_ITEM", 0x291 => "SMSG_CHAT_SERVER_MESSAGE", 0x292 => "CMSG_SET_SAVED_INSTANCE_EXTEND", 0x293 => "SMSG_LFG_OFFER_CONTINUE", 0x294 => "CMSG_TEST_DROP_RATE", 0x295 => "SMSG_TEST_DROP_RATE_RESULT", 0x296 => "CMSG_LFG_GET_STATUS", 0x297 => "SMSG_SHOW_MAILBOX", 0x298 => "SMSG_RESET_RANGED_COMBAT_TIMER", 0x299 => "SMSG_CHAT_NOT_IN_PARTY", 0x29A => "CMSG_GMTICKETSYSTEM_TOGGLE", 0x29B => "CMSG_CANCEL_GROWTH_AURA", 0x29C => "SMSG_CANCEL_AUTO_REPEAT", 0x29D => "SMSG_STANDSTATE_UPDATE", 0x29E => "SMSG_LOOT_ALL_PASSED", 0x29F => "SMSG_LOOT_ROLL_WON", 0x2A0 => "CMSG_LOOT_ROLL", 0x2A1 => "SMSG_LOOT_START_ROLL", 0x2A2 => "SMSG_LOOT_ROLL", 0x2A3 => "CMSG_LOOT_MASTER_GIVE", 0x2A4 => "SMSG_LOOT_MASTER_LIST", 0x2A5 => "SMSG_SET_FORCED_REACTIONS", 0x2A6 => "SMSG_SPELL_FAILED_OTHER", 0x2A7 => "SMSG_GAMEOBJECT_RESET_STATE", 0x2A8 => "CMSG_REPAIR_ITEM", 0x2A9 => "SMSG_CHAT_PLAYER_NOT_FOUND", 0x2AA => "MSG_TALENT_WIPE_CONFIRM", 0x2AB => "SMSG_SUMMON_REQUEST", 0x2AC => "CMSG_SUMMON_RESPONSE", 0x2AD => "MSG_DEV_SHOWLABEL", 0x2AE => "SMSG_MONSTER_MOVE_TRANSPORT", 0x2AF => "SMSG_PET_BROKEN", 0x2B0 => "MSG_MOVE_FEATHER_FALL", 0x2B1 => "MSG_MOVE_WATER_WALK", 0x2B2 => "CMSG_SERVER_BROADCAST", 0x2B3 => "CMSG_SELF_RES", 0x2B4 => "SMSG_FEIGN_DEATH_RESISTED", 0x2B5 => "CMSG_RUN_SCRIPT", 0x2B6 => "SMSG_SCRIPT_MESSAGE", 0x2B7 => "SMSG_DUEL_COUNTDOWN", 0x2B8 => "SMSG_AREA_TRIGGER_MESSAGE", 0x2B9 => "CMSG_SHOWING_HELM", 0x2BA => "CMSG_SHOWING_CLOAK", 0x2BB => "SMSG_LFG_ROLE_CHOSEN", 0x2BC => "SMSG_PLAYER_SKINNED", 0x2BD => "SMSG_DURABILITY_DAMAGE_DEATH", 0x2BE => "CMSG_SET_EXPLORATION", 0x2BF => "CMSG_SET_ACTIONBAR_TOGGLES", 0x2C0 => "UMSG_DELETE_GUILD_CHARTER", 0x2C1 => "MSG_PETITION_RENAME", 0x2C2 => "SMSG_INIT_WORLD_STATES", 0x2C3 => "SMSG_UPDATE_WORLD_STATE", 0x2C4 => "CMSG_ITEM_NAME_QUERY", 0x2C5 => "SMSG_ITEM_NAME_QUERY_RESPONSE", 0x2C6 => "SMSG_PET_ACTION_FEEDBACK", 0x2C7 => "CMSG_CHAR_RENAME", 0x2C8 => "SMSG_CHAR_RENAME", 0x2C9 => "CMSG_MOVE_SPLINE_DONE", 0x2CA => "CMSG_MOVE_FALL_RESET", 0x2CB => "SMSG_INSTANCE_SAVE_CREATED", 0x2CC => "SMSG_RAID_INSTANCE_INFO", 0x2CD => "CMSG_REQUEST_RAID_INFO", 0x2CE => "CMSG_MOVE_TIME_SKIPPED", 0x2CF => "CMSG_MOVE_FEATHER_FALL_ACK", 0x2D0 => "CMSG_MOVE_WATER_WALK_ACK", 0x2D1 => "CMSG_MOVE_NOT_ACTIVE_MOVER", 0x2D2 => "SMSG_PLAY_SOUND", 0x2D3 => "CMSG_BATTLEFIELD_STATUS", 0x2D4 => "SMSG_BATTLEFIELD_STATUS", 0x2D5 => "CMSG_BATTLEFIELD_PORT", 0x2D6 => "MSG_INSPECT_HONOR_STATS", 0x2D7 => "CMSG_BATTLEMASTER_HELLO", 0x2D8 => "CMSG_MOVE_START_SWIM_CHEAT", 0x2D9 => "CMSG_MOVE_STOP_SWIM_CHEAT", 0x2DA => "SMSG_FORCE_WALK_SPEED_CHANGE", 0x2DB => "CMSG_FORCE_WALK_SPEED_CHANGE_ACK", 0x2DC => "SMSG_FORCE_SWIM_BACK_SPEED_CHANGE", 0x2DD => "CMSG_FORCE_SWIM_BACK_SPEED_CHANGE_ACK", 0x2DE => "SMSG_FORCE_TURN_RATE_CHANGE", 0x2DF => "CMSG_FORCE_TURN_RATE_CHANGE_ACK", 0x2E0 => "MSG_PVP_LOG_DATA", 0x2E1 => "CMSG_LEAVE_BATTLEFIELD", 0x2E2 => "CMSG_AREA_SPIRIT_HEALER_QUERY", 0x2E3 => "CMSG_AREA_SPIRIT_HEALER_QUEUE", 0x2E4 => "SMSG_AREA_SPIRIT_HEALER_TIME", 0x2E5 => "CMSG_GM_UNTEACH", 0x2E6 => "SMSG_WARDEN_DATA", 0x2E7 => "CMSG_WARDEN_DATA", 0x2E8 => "SMSG_GROUP_JOINED_BATTLEGROUND", 0x2E9 => "MSG_BATTLEGROUND_PLAYER_POSITIONS", 0x2EA => "CMSG_PET_STOP_ATTACK", 0x2EB => "SMSG_BINDER_CONFIRM", 0x2EC => "SMSG_BATTLEGROUND_PLAYER_JOINED", 0x2ED => "SMSG_BATTLEGROUND_PLAYER_LEFT", 0x2EE => "CMSG_BATTLEMASTER_JOIN", 0x2EF => "SMSG_ADDON_INFO", 0x2F0 => "CMSG_PET_UNLEARN", 0x2F1 => "SMSG_PET_UNLEARN_CONFIRM", 0x2F2 => "SMSG_PARTY_MEMBER_STATS_FULL", 0x2F3 => "CMSG_PET_SPELL_AUTOCAST", 0x2F4 => "SMSG_WEATHER", 0x2F5 => "SMSG_PLAY_TIME_WARNING", 0x2F6 => "SMSG_MINIGAME_SETUP", 0x2F7 => "SMSG_MINIGAME_STATE", 0x2F8 => "CMSG_MINIGAME_MOVE", 0x2F9 => "SMSG_MINIGAME_MOVE_FAILED", 0x2FA => "SMSG_RAID_INSTANCE_MESSAGE", 0x2FB => "SMSG_COMPRESSED_MOVES", 0x2FC => "CMSG_GUILD_INFO_TEXT", 0x2FD => "SMSG_CHAT_RESTRICTED", 0x2FE => "SMSG_SPLINE_SET_RUN_SPEED", 0x2FF => "SMSG_SPLINE_SET_RUN_BACK_SPEED", 0x300 => "SMSG_SPLINE_SET_SWIM_SPEED", 0x301 => "SMSG_SPLINE_SET_WALK_SPEED", 0x302 => "SMSG_SPLINE_SET_SWIM_BACK_SPEED", 0x303 => "SMSG_SPLINE_SET_TURN_RATE", 0x304 => "SMSG_SPLINE_MOVE_UNROOT", 0x305 => "SMSG_SPLINE_MOVE_FEATHER_FALL", 0x306 => "SMSG_SPLINE_MOVE_NORMAL_FALL", 0x307 => "SMSG_SPLINE_MOVE_SET_HOVER", 0x308 => "SMSG_SPLINE_MOVE_UNSET_HOVER", 0x309 => "SMSG_SPLINE_MOVE_WATER_WALK", 0x30A => "SMSG_SPLINE_MOVE_LAND_WALK", 0x30B => "SMSG_SPLINE_MOVE_START_SWIM", 0x30C => "SMSG_SPLINE_MOVE_STOP_SWIM", 0x30D => "SMSG_SPLINE_MOVE_SET_RUN_MODE", 0x30E => "SMSG_SPLINE_MOVE_SET_WALK_MODE", 0x30F => "CMSG_GM_NUKE_ACCOUNT", 0x310 => "MSG_GM_DESTROY_CORPSE", 0x311 => "CMSG_GM_DESTROY_ONLINE_CORPSE", 0x312 => "CMSG_ACTIVATETAXIEXPRESS", 0x313 => "SMSG_SET_FACTION_ATWAR", 0x314 => "SMSG_GAMETIMEBIAS_SET", 0x315 => "CMSG_DEBUG_ACTIONS_START", 0x316 => "CMSG_DEBUG_ACTIONS_STOP", 0x317 => "CMSG_SET_FACTION_INACTIVE", 0x318 => "CMSG_SET_WATCHED_FACTION", 0x319 => "MSG_MOVE_TIME_SKIPPED", 0x31A => "SMSG_SPLINE_MOVE_ROOT", 0x31B => "CMSG_SET_EXPLORATION_ALL", 0x31C => "SMSG_INVALIDATE_PLAYER", 0x31D => "CMSG_RESET_INSTANCES", 0x31E => "SMSG_INSTANCE_RESET", 0x31F => "SMSG_INSTANCE_RESET_FAILED", 0x320 => "SMSG_UPDATE_LAST_INSTANCE", 0x321 => "MSG_RAID_TARGET_UPDATE", 0x322 => "MSG_RAID_READY_CHECK", 0x323 => "CMSG_LUA_USAGE", 0x324 => "SMSG_PET_ACTION_SOUND", 0x325 => "SMSG_PET_DISMISS_SOUND", 0x326 => "SMSG_GHOSTEE_GONE", 0x327 => "CMSG_GM_UPDATE_TICKET_STATUS", 0x328 => "SMSG_GM_TICKET_STATUS_UPDATE", 0x329 => "MSG_SET_DUNGEON_DIFFICULTY", 0x32A => "CMSG_GMSURVEY_SUBMIT", 0x32B => "SMSG_UPDATE_INSTANCE_OWNERSHIP", 0x32C => "CMSG_IGNORE_KNOCKBACK_CHEAT", 0x32D => "SMSG_CHAT_PLAYER_AMBIGUOUS", 0x32E => "MSG_DELAY_GHOST_TELEPORT", 0x32F => "SMSG_SPELLINSTAKILLLOG", 0x330 => "SMSG_SPELL_UPDATE_CHAIN_TARGETS", 0x331 => "CMSG_CHAT_FILTERED", 0x332 => "SMSG_EXPECTED_SPAM_RECORDS", 0x333 => "SMSG_SPELLSTEALLOG", 0x334 => "CMSG_LOTTERY_QUERY_OBSOLETE", 0x335 => "SMSG_LOTTERY_QUERY_RESULT_OBSOLETE", 0x336 => "CMSG_BUY_LOTTERY_TICKET_OBSOLETE", 0x337 => "SMSG_LOTTERY_RESULT_OBSOLETE", 0x338 => "SMSG_CHARACTER_PROFILE", 0x339 => "SMSG_CHARACTER_PROFILE_REALM_CONNECTED", 0x33A => "SMSG_DEFENSE_MESSAGE", 0x33B => "SMSG_INSTANCE_DIFFICULTY", 0x33C => "MSG_GM_RESETINSTANCELIMIT", 0x33D => "SMSG_MOTD", 0x33E => "SMSG_MOVE_SET_CAN_TRANSITION_BETWEEN_SWIM_AND_FLY", 0x33F => "SMSG_MOVE_UNSET_CAN_TRANSITION_BETWEEN_SWIM_AND_FLY", 0x340 => "CMSG_MOVE_SET_CAN_TRANSITION_BETWEEN_SWIM_AND_FLY_ACK", 0x341 => "MSG_MOVE_START_SWIM_CHEAT", 0x342 => "MSG_MOVE_STOP_SWIM_CHEAT", 0x343 => "SMSG_MOVE_SET_CAN_FLY", 0x344 => "SMSG_MOVE_UNSET_CAN_FLY", 0x345 => "CMSG_MOVE_SET_CAN_FLY_ACK", 0x346 => "CMSG_MOVE_SET_FLY", 0x347 => "CMSG_SOCKET_GEMS", 0x348 => "CMSG_ARENA_TEAM_CREATE", 0x349 => "SMSG_ARENA_TEAM_COMMAND_RESULT", 0x34A => "MSG_MOVE_UPDATE_CAN_TRANSITION_BETWEEN_SWIM_AND_FLY", 0x34B => "CMSG_ARENA_TEAM_QUERY", 0x34C => "SMSG_ARENA_TEAM_QUERY_RESPONSE", 0x34D => "CMSG_ARENA_TEAM_ROSTER", 0x34E => "SMSG_ARENA_TEAM_ROSTER", 0x34F => "CMSG_ARENA_TEAM_INVITE", 0x350 => "SMSG_ARENA_TEAM_INVITE", 0x351 => "CMSG_ARENA_TEAM_ACCEPT", 0x352 => "CMSG_ARENA_TEAM_DECLINE", 0x353 => "CMSG_ARENA_TEAM_LEAVE", 0x354 => "CMSG_ARENA_TEAM_REMOVE", 0x355 => "CMSG_ARENA_TEAM_DISBAND", 0x356 => "CMSG_ARENA_TEAM_LEADER", 0x357 => "SMSG_ARENA_TEAM_EVENT", 0x358 => "CMSG_BATTLEMASTER_JOIN_ARENA", 0x359 => "MSG_MOVE_START_ASCEND", 0x35A => "MSG_MOVE_STOP_ASCEND", 0x35B => "SMSG_ARENA_TEAM_STATS", 0x35C => "CMSG_LFG_JOIN", 0x35D => "CMSG_LFG_LEAVE", 0x35E => "CMSG_SEARCH_LFG_JOIN", 0x35F => "CMSG_SEARCH_LFG_LEAVE", 0x360 => "SMSG_UPDATE_LFG_LIST", 0x361 => "SMSG_LFG_PROPOSAL_UPDATE", 0x362 => "CMSG_LFG_PROPOSAL_RESULT", 0x363 => "SMSG_LFG_ROLE_CHECK_UPDATE", 0x364 => "SMSG_LFG_JOIN_RESULT", 0x365 => "SMSG_LFG_QUEUE_STATUS", 0x366 => "CMSG_SET_LFG_COMMENT", 0x367 => "SMSG_LFG_UPDATE_PLAYER", 0x368 => "SMSG_LFG_UPDATE_PARTY", 0x369 => "SMSG_LFG_UPDATE_SEARCH", 0x36A => "CMSG_LFG_SET_ROLES", 0x36B => "CMSG_LFG_SET_NEEDS", 0x36C => "CMSG_LFG_SET_BOOT_VOTE", 0x36D => "SMSG_LFG_BOOT_PROPOSAL_UPDATE", 0x36E => "CMSG_LFD_PLAYER_LOCK_INFO_REQUEST", 0x36F => "SMSG_LFG_PLAYER_INFO", 0x370 => "CMSG_LFG_TELEPORT", 0x371 => "CMSG_LFD_PARTY_LOCK_INFO_REQUEST", 0x372 => "SMSG_LFG_PARTY_INFO", 0x373 => "SMSG_TITLE_EARNED", 0x374 => "CMSG_SET_TITLE", 0x375 => "CMSG_CANCEL_MOUNT_AURA", 0x376 => "SMSG_ARENA_ERROR", 0x377 => "MSG_INSPECT_ARENA_TEAMS", 0x378 => "SMSG_DEATH_RELEASE_LOC", 0x379 => "CMSG_CANCEL_TEMP_ENCHANTMENT", 0x37A => "SMSG_FORCED_DEATH_UPDATE", 0x37B => "CMSG_CHEAT_SET_HONOR_CURRENCY", 0x37C => "CMSG_CHEAT_SET_ARENA_CURRENCY", 0x37D => "MSG_MOVE_SET_FLIGHT_SPEED_CHEAT", 0x37E => "MSG_MOVE_SET_FLIGHT_SPEED", 0x37F => "MSG_MOVE_SET_FLIGHT_BACK_SPEED_CHEAT", 0x380 => "MSG_MOVE_SET_FLIGHT_BACK_SPEED", 0x381 => "SMSG_FORCE_FLIGHT_SPEED_CHANGE", 0x382 => "CMSG_FORCE_FLIGHT_SPEED_CHANGE_ACK", 0x383 => "SMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE", 0x384 => "CMSG_FORCE_FLIGHT_BACK_SPEED_CHANGE_ACK", 0x385 => "SMSG_SPLINE_SET_FLIGHT_SPEED", 0x386 => "SMSG_SPLINE_SET_FLIGHT_BACK_SPEED", 0x387 => "CMSG_MAELSTROM_INVALIDATE_CACHE", 0x388 => "SMSG_FLIGHT_SPLINE_SYNC", 0x389 => "CMSG_SET_TAXI_BENCHMARK_MODE", 0x38A => "SMSG_JOINED_BATTLEGROUND_QUEUE", 0x38B => "SMSG_REALM_SPLIT", 0x38C => "CMSG_REALM_SPLIT", 0x38D => "CMSG_MOVE_CHNG_TRANSPORT", 0x38E => "MSG_PARTY_ASSIGNMENT", 0x38F => "SMSG_OFFER_PETITION_ERROR", 0x390 => "SMSG_TIME_SYNC_REQ", 0x391 => "CMSG_TIME_SYNC_RESP", 0x392 => "CMSG_SEND_LOCAL_EVENT", 0x393 => "CMSG_SEND_GENERAL_TRIGGER", 0x394 => "CMSG_SEND_COMBAT_TRIGGER", 0x395 => "CMSG_MAELSTROM_GM_SENT_MAIL", 0x396 => "SMSG_RESET_FAILED_NOTIFY", 0x397 => "SMSG_REAL_GROUP_UPDATE", 0x398 => "SMSG_LFG_DISABLED", 0x399 => "CMSG_ACTIVE_PVP_CHEAT", 0x39A => "CMSG_CHEAT_DUMP_ITEMS_DEBUG_ONLY", 0x39B => "SMSG_CHEAT_DUMP_ITEMS_DEBUG_ONLY_RESPONSE", 0x39C => "SMSG_CHEAT_DUMP_ITEMS_DEBUG_ONLY_RESPONSE_WRITE_FILE", 0x39D => "SMSG_UPDATE_COMBO_POINTS", 0x39E => "SMSG_VOICE_SESSION_ROSTER_UPDATE", 0x39F => "SMSG_VOICE_SESSION_LEAVE", 0x3A0 => "SMSG_VOICE_SESSION_ADJUST_PRIORITY", 0x3A1 => "CMSG_VOICE_SET_TALKER_MUTED_REQUEST", 0x3A2 => "SMSG_VOICE_SET_TALKER_MUTED", 0x3A3 => "SMSG_INIT_EXTRA_AURA_INFO_OBSOLETE", 0x3A4 => "SMSG_SET_EXTRA_AURA_INFO_OBSOLETE", 0x3A5 => "SMSG_SET_EXTRA_AURA_INFO_NEED_UPDATE_OBSOLETE", 0x3A6 => "SMSG_CLEAR_EXTRA_AURA_INFO_OBSOLETE", 0x3A7 => "MSG_MOVE_START_DESCEND", 0x3A8 => "CMSG_IGNORE_REQUIREMENTS_CHEAT", 0x3A9 => "SMSG_IGNORE_REQUIREMENTS_CHEAT", 0x3AA => "SMSG_SPELL_CHANCE_PROC_LOG", 0x3AB => "CMSG_MOVE_SET_RUN_SPEED", 0x3AC => "SMSG_DISMOUNT", 0x3AD => "MSG_MOVE_UPDATE_CAN_FLY", 0x3AE => "MSG_RAID_READY_CHECK_CONFIRM", 0x3AF => "CMSG_VOICE_SESSION_ENABLE", 0x3B0 => "SMSG_VOICE_SESSION_ENABLE", 0x3B1 => "SMSG_VOICE_PARENTAL_CONTROLS", 0x3B2 => "CMSG_GM_WHISPER", 0x3B3 => "SMSG_GM_MESSAGECHAT", 0x3B4 => "MSG_GM_GEARRATING", 0x3B5 => "CMSG_COMMENTATOR_ENABLE", 0x3B6 => "SMSG_COMMENTATOR_STATE_CHANGED", 0x3B7 => "CMSG_COMMENTATOR_GET_MAP_INFO", 0x3B8 => "SMSG_COMMENTATOR_MAP_INFO", 0x3B9 => "CMSG_COMMENTATOR_GET_PLAYER_INFO", 0x3BA => "SMSG_COMMENTATOR_GET_PLAYER_INFO", 0x3BB => "SMSG_COMMENTATOR_PLAYER_INFO", 0x3BC => "CMSG_COMMENTATOR_ENTER_INSTANCE", 0x3BD => "CMSG_COMMENTATOR_EXIT_INSTANCE", 0x3BE => "CMSG_COMMENTATOR_INSTANCE_COMMAND", 0x3BF => "SMSG_CLEAR_TARGET", 0x3C0 => "CMSG_BOT_DETECTED", 0x3C1 => "SMSG_CROSSED_INEBRIATION_THRESHOLD", 0x3C2 => "CMSG_CHEAT_PLAYER_LOGIN", 0x3C3 => "CMSG_CHEAT_PLAYER_LOOKUP", 0x3C4 => "SMSG_CHEAT_PLAYER_LOOKUP", 0x3C5 => "SMSG_KICK_REASON", 0x3C6 => "MSG_RAID_READY_CHECK_FINISHED", 0x3C7 => "CMSG_COMPLAIN", 0x3C8 => "SMSG_COMPLAIN_RESULT", 0x3C9 => "SMSG_FEATURE_SYSTEM_STATUS", 0x3CA => "CMSG_GM_SHOW_COMPLAINTS", 0x3CB => "CMSG_GM_UNSQUELCH", 0x3CC => "CMSG_CHANNEL_SILENCE_VOICE", 0x3CD => "CMSG_CHANNEL_SILENCE_ALL", 0x3CE => "CMSG_CHANNEL_UNSILENCE_VOICE", 0x3CF => "CMSG_CHANNEL_UNSILENCE_ALL", 0x3D0 => "CMSG_TARGET_CAST", 0x3D1 => "CMSG_TARGET_SCRIPT_CAST", 0x3D2 => "CMSG_CHANNEL_DISPLAY_LIST", 0x3D3 => "CMSG_SET_ACTIVE_VOICE_CHANNEL", 0x3D4 => "CMSG_GET_CHANNEL_MEMBER_COUNT", 0x3D5 => "SMSG_CHANNEL_MEMBER_COUNT", 0x3D6 => "CMSG_CHANNEL_VOICE_ON", 0x3D7 => "CMSG_CHANNEL_VOICE_OFF", 0x3D8 => "CMSG_DEBUG_LIST_TARGETS", 0x3D9 => "SMSG_DEBUG_LIST_TARGETS", 0x3DA => "SMSG_AVAILABLE_VOICE_CHANNEL", 0x3DB => "CMSG_ADD_VOICE_IGNORE", 0x3DC => "CMSG_DEL_VOICE_IGNORE", 0x3DD => "CMSG_PARTY_SILENCE", 0x3DE => "CMSG_PARTY_UNSILENCE", 0x3DF => "MSG_NOTIFY_PARTY_SQUELCH", 0x3E0 => "SMSG_COMSAT_RECONNECT_TRY", 0x3E1 => "SMSG_COMSAT_DISCONNECT", 0x3E2 => "SMSG_COMSAT_CONNECT_FAIL", 0x3E3 => "SMSG_VOICE_CHAT_STATUS", 0x3E4 => "CMSG_REPORT_PVP_AFK", 0x3E5 => "SMSG_REPORT_PVP_AFK_RESULT", 0x3E6 => "CMSG_GUILD_BANKER_ACTIVATE", 0x3E7 => "CMSG_GUILD_BANK_QUERY_TAB", 0x3E8 => "SMSG_GUILD_BANK_LIST", 0x3E9 => "CMSG_GUILD_BANK_SWAP_ITEMS", 0x3EA => "CMSG_GUILD_BANK_BUY_TAB", 0x3EB => "CMSG_GUILD_BANK_UPDATE_TAB", 0x3EC => "CMSG_GUILD_BANK_DEPOSIT_MONEY", 0x3ED => "CMSG_GUILD_BANK_WITHDRAW_MONEY", 0x3EE => "MSG_GUILD_BANK_LOG_QUERY", 0x3EF => "CMSG_SET_CHANNEL_WATCH", 0x3F0 => "SMSG_USERLIST_ADD", 0x3F1 => "SMSG_USERLIST_REMOVE", 0x3F2 => "SMSG_USERLIST_UPDATE", 0x3F3 => "CMSG_CLEAR_CHANNEL_WATCH", 0x3F4 => "SMSG_INSPECT_TALENT", 0x3F5 => "SMSG_GOGOGO_OBSOLETE", 0x3F6 => "SMSG_ECHO_PARTY_SQUELCH", 0x3F7 => "CMSG_SET_TITLE_SUFFIX", 0x3F8 => "CMSG_SPELLCLICK", 0x3F9 => "SMSG_LOOT_LIST", 0x3FA => "CMSG_GM_CHARACTER_RESTORE", 0x3FB => "CMSG_GM_CHARACTER_SAVE", 0x3FC => "SMSG_VOICESESSION_FULL", 0x3FD => "MSG_GUILD_PERMISSIONS", 0x3FE => "MSG_GUILD_BANK_MONEY_WITHDRAWN", 0x3FF => "MSG_GUILD_EVENT_LOG_QUERY", 0x400 => "CMSG_MAELSTROM_RENAME_GUILD", 0x401 => "CMSG_GET_MIRRORIMAGE_DATA", 0x402 => "SMSG_MIRRORIMAGE_DATA", 0x403 => "SMSG_FORCE_DISPLAY_UPDATE", 0x404 => "SMSG_SPELL_CHANCE_RESIST_PUSHBACK", 0x405 => "CMSG_IGNORE_DIMINISHING_RETURNS_CHEAT", 0x406 => "SMSG_IGNORE_DIMINISHING_RETURNS_CHEAT", 0x407 => "CMSG_KEEP_ALIVE", 0x408 => "SMSG_RAID_READY_CHECK_ERROR", 0x409 => "CMSG_OPT_OUT_OF_LOOT", 0x40A => "MSG_QUERY_GUILD_BANK_TEXT", 0x40B => "CMSG_SET_GUILD_BANK_TEXT", 0x40C => "CMSG_SET_GRANTABLE_LEVELS", 0x40D => "CMSG_GRANT_LEVEL", 0x40E => "CMSG_REFER_A_FRIEND", 0x40F => "MSG_GM_CHANGE_ARENA_RATING", 0x410 => "CMSG_DECLINE_CHANNEL_INVITE", 0x411 => "SMSG_GROUPACTION_THROTTLED", 0x412 => "SMSG_OVERRIDE_LIGHT", 0x413 => "SMSG_TOTEM_CREATED", 0x414 => "CMSG_TOTEM_DESTROYED", 0x415 => "CMSG_EXPIRE_RAID_INSTANCE", 0x416 => "CMSG_NO_SPELL_VARIANCE", 0x417 => "CMSG_QUESTGIVER_STATUS_MULTIPLE_QUERY", 0x418 => "SMSG_QUESTGIVER_STATUS_MULTIPLE", 0x419 => "CMSG_SET_PLAYER_DECLINED_NAMES", 0x41A => "SMSG_SET_PLAYER_DECLINED_NAMES_RESULT", 0x41B => "CMSG_QUERY_SERVER_BUCK_DATA", 0x41C => "CMSG_CLEAR_SERVER_BUCK_DATA", 0x41D => "SMSG_SERVER_BUCK_DATA", 0x41E => "SMSG_SEND_UNLEARN_SPELLS", 0x41F => "SMSG_PROPOSE_LEVEL_GRANT", 0x420 => "CMSG_ACCEPT_LEVEL_GRANT", 0x421 => "SMSG_REFER_A_FRIEND_FAILURE", 0x422 => "SMSG_SPLINE_MOVE_SET_FLYING", 0x423 => "SMSG_SPLINE_MOVE_UNSET_FLYING", 0x424 => "SMSG_SUMMON_CANCEL", 0x425 => "CMSG_CHANGE_PERSONAL_ARENA_RATING", 0x426 => "CMSG_ALTER_APPEARANCE", 0x427 => "SMSG_ENABLE_BARBER_SHOP", 0x428 => "SMSG_BARBER_SHOP_RESULT", 0x429 => "CMSG_CALENDAR_GET_CALENDAR", 0x42A => "CMSG_CALENDAR_GET_EVENT", 0x42B => "CMSG_CALENDAR_GUILD_FILTER", 0x42C => "CMSG_CALENDAR_ARENA_TEAM", 0x42D => "CMSG_CALENDAR_ADD_EVENT", 0x42E => "CMSG_CALENDAR_UPDATE_EVENT", 0x42F => "CMSG_CALENDAR_REMOVE_EVENT", 0x430 => "CMSG_CALENDAR_COPY_EVENT", 0x431 => "CMSG_CALENDAR_EVENT_INVITE", 0x432 => "CMSG_CALENDAR_EVENT_RSVP", 0x433 => "CMSG_CALENDAR_EVENT_REMOVE_INVITE", 0x434 => "CMSG_CALENDAR_EVENT_STATUS", 0x435 => "CMSG_CALENDAR_EVENT_MODERATOR_STATUS", 0x436 => "SMSG_CALENDAR_SEND_CALENDAR", 0x437 => "SMSG_CALENDAR_SEND_EVENT", 0x438 => "SMSG_CALENDAR_FILTER_GUILD", 0x439 => "SMSG_CALENDAR_ARENA_TEAM", 0x43A => "SMSG_CALENDAR_EVENT_INVITE", 0x43B => "SMSG_CALENDAR_EVENT_INVITE_REMOVED", 0x43C => "SMSG_CALENDAR_EVENT_STATUS", 0x43D => "SMSG_CALENDAR_COMMAND_RESULT", 0x43E => "SMSG_CALENDAR_RAID_LOCKOUT_ADDED", 0x43F => "SMSG_CALENDAR_RAID_LOCKOUT_REMOVED", 0x440 => "SMSG_CALENDAR_EVENT_INVITE_ALERT", 0x441 => "SMSG_CALENDAR_EVENT_INVITE_REMOVED_ALERT", 0x442 => "SMSG_CALENDAR_EVENT_INVITE_STATUS_ALERT", 0x443 => "SMSG_CALENDAR_EVENT_REMOVED_ALERT", 0x444 => "SMSG_CALENDAR_EVENT_UPDATED_ALERT", 0x445 => "SMSG_CALENDAR_EVENT_MODERATOR_STATUS_ALERT", 0x446 => "CMSG_CALENDAR_COMPLAIN", 0x447 => "CMSG_CALENDAR_GET_NUM_PENDING", 0x448 => "SMSG_CALENDAR_SEND_NUM_PENDING", 0x449 => "CMSG_SAVE_DANCE", 0x44A => "SMSG_NOTIFY_DANCE", 0x44B => "CMSG_PLAY_DANCE", 0x44C => "SMSG_PLAY_DANCE", 0x44D => "CMSG_LOAD_DANCES", 0x44E => "CMSG_STOP_DANCE", 0x44F => "SMSG_STOP_DANCE", 0x450 => "CMSG_SYNC_DANCE", 0x451 => "CMSG_DANCE_QUERY", 0x452 => "SMSG_DANCE_QUERY_RESPONSE", 0x453 => "SMSG_INVALIDATE_DANCE", 0x454 => "CMSG_DELETE_DANCE", 0x455 => "SMSG_LEARNED_DANCE_MOVES", 0x456 => "CMSG_LEARN_DANCE_MOVE", 0x457 => "CMSG_UNLEARN_DANCE_MOVE", 0x458 => "CMSG_SET_RUNE_COUNT", 0x459 => "CMSG_SET_RUNE_COOLDOWN", 0x45A => "MSG_MOVE_SET_PITCH_RATE_CHEAT", 0x45B => "MSG_MOVE_SET_PITCH_RATE", 0x45C => "SMSG_FORCE_PITCH_RATE_CHANGE", 0x45D => "CMSG_FORCE_PITCH_RATE_CHANGE_ACK", 0x45E => "SMSG_SPLINE_SET_PITCH_RATE", 0x45F => "CMSG_CALENDAR_EVENT_INVITE_NOTES", 0x460 => "SMSG_CALENDAR_EVENT_INVITE_NOTES", 0x461 => "SMSG_CALENDAR_EVENT_INVITE_NOTES_ALERT", 0x462 => "CMSG_UPDATE_MISSILE_TRAJECTORY", 0x463 => "SMSG_UPDATE_ACCOUNT_DATA_COMPLETE", 0x464 => "SMSG_TRIGGER_MOVIE", 0x465 => "CMSG_COMPLETE_MOVIE", 0x466 => "CMSG_SET_GLYPH_SLOT", 0x467 => "CMSG_SET_GLYPH", 0x468 => "SMSG_ACHIEVEMENT_EARNED", 0x469 => "SMSG_DYNAMIC_DROP_ROLL_RESULT", 0x46A => "SMSG_CRITERIA_UPDATE", 0x46B => "CMSG_QUERY_INSPECT_ACHIEVEMENTS", 0x46C => "SMSG_RESPOND_INSPECT_ACHIEVEMENTS", 0x46D => "CMSG_DISMISS_CONTROLLED_VEHICLE", 0x46E => "CMSG_COMPLETE_ACHIEVEMENT_CHEAT", 0x46F => "SMSG_QUESTUPDATE_ADD_PVP_KILL", 0x470 => "CMSG_SET_CRITERIA_CHEAT", 0x471 => "SMSG_CALENDAR_RAID_LOCKOUT_UPDATED", 0x472 => "CMSG_UNITANIMTIER_CHEAT", 0x473 => "CMSG_CHAR_CUSTOMIZE", 0x474 => "SMSG_CHAR_CUSTOMIZE", 0x475 => "SMSG_PET_RENAMEABLE", 0x476 => "CMSG_REQUEST_VEHICLE_EXIT", 0x477 => "CMSG_REQUEST_VEHICLE_PREV_SEAT", 0x478 => "CMSG_REQUEST_VEHICLE_NEXT_SEAT", 0x479 => "CMSG_REQUEST_VEHICLE_SWITCH_SEAT", 0x47A => "CMSG_PET_LEARN_TALENT", 0x47B => "CMSG_PET_UNLEARN_TALENTS", 0x47C => "SMSG_SET_PHASE_SHIFT", 0x47D => "SMSG_ALL_ACHIEVEMENT_DATA", 0x47E => "CMSG_FORCE_SAY_CHEAT", 0x47F => "SMSG_HEALTH_UPDATE", 0x480 => "SMSG_POWER_UPDATE", 0x481 => "CMSG_GAMEOBJ_REPORT_USE", 0x482 => "SMSG_HIGHEST_THREAT_UPDATE", 0x483 => "SMSG_THREAT_UPDATE", 0x484 => "SMSG_THREAT_REMOVE", 0x485 => "SMSG_THREAT_CLEAR", 0x486 => "SMSG_CONVERT_RUNE", 0x487 => "SMSG_RESYNC_RUNES", 0x488 => "SMSG_ADD_RUNE_POWER", 0x489 => "CMSG_START_QUEST", 0x48A => "CMSG_REMOVE_GLYPH", 0x48B => "CMSG_DUMP_OBJECTS", 0x48C => "SMSG_DUMP_OBJECTS_DATA", 0x48D => "CMSG_DISMISS_CRITTER", 0x48E => "SMSG_NOTIFY_DEST_LOC_SPELL_CAST", 0x48F => "CMSG_AUCTION_LIST_PENDING_SALES", 0x490 => "SMSG_AUCTION_LIST_PENDING_SALES", 0x491 => "SMSG_MODIFY_COOLDOWN", 0x492 => "SMSG_PET_UPDATE_COMBO_POINTS", 0x493 => "CMSG_ENABLETAXI", 0x494 => "SMSG_PRE_RESURRECT", 0x495 => "SMSG_AURA_UPDATE_ALL", 0x496 => "SMSG_AURA_UPDATE", 0x497 => "CMSG_FLOOD_GRACE_CHEAT", 0x498 => "SMSG_SERVER_FIRST_ACHIEVEMENT", 0x499 => "SMSG_PET_LEARNED_SPELL", 0x49A => "SMSG_PET_UNLEARNED_SPELL", 0x49B => "CMSG_CHANGE_SEATS_ON_CONTROLLED_VEHICLE", 0x49C => "CMSG_HEARTH_AND_RESURRECT", 0x49D => "SMSG_ON_CANCEL_EXPECTED_RIDE_VEHICLE_AURA", 0x49E => "SMSG_CRITERIA_DELETED", 0x49F => "SMSG_ACHIEVEMENT_DELETED", 0x4A0 => "CMSG_SERVER_INFO_QUERY", 0x4A1 => "SMSG_SERVER_INFO_RESPONSE", 0x4A2 => "CMSG_CHECK_LOGIN_CRITERIA", 0x4A3 => "SMSG_SERVER_BUCK_DATA_START", 0x4A4 => "CMSG_SET_BREATH", 0x4A5 => "CMSG_QUERY_VEHICLE_STATUS", 0x4A6 => "SMSG_BATTLEGROUND_INFO_THROTTLED", 0x4A7 => "SMSG_PLAYER_VEHICLE_DATA", 0x4A8 => "CMSG_PLAYER_VEHICLE_ENTER", 0x4A9 => "CMSG_CONTROLLER_EJECT_PASSENGER", 0x4AA => "SMSG_PET_GUIDS", 0x4AB => "SMSG_CLIENTCACHE_VERSION", 0x4AC => "CMSG_CHANGE_GDF_ARENA_RATING", 0x4AD => "CMSG_SET_ARENA_TEAM_RATING_BY_INDEX", 0x4AE => "CMSG_SET_ARENA_TEAM_WEEKLY_GAMES", 0x4AF => "CMSG_SET_ARENA_TEAM_SEASON_GAMES", 0x4B0 => "CMSG_SET_ARENA_MEMBER_WEEKLY_GAMES", 0x4B1 => "CMSG_SET_ARENA_MEMBER_SEASON_GAMES", 0x4B2 => "SMSG_ITEM_REFUND_INFO_RESPONSE", 0x4B3 => "CMSG_ITEM_REFUND_INFO", 0x4B4 => "CMSG_ITEM_REFUND", 0x4B5 => "SMSG_ITEM_REFUND_RESULT", 0x4B6 => "CMSG_CORPSE_MAP_POSITION_QUERY", 0x4B7 => "SMSG_CORPSE_MAP_POSITION_QUERY_RESPONSE", 0x4B8 => "CMSG_UNUSED5", 0x4B9 => "CMSG_UNUSED6", 0x4BA => "CMSG_CALENDAR_EVENT_SIGNUP", 0x4BB => "SMSG_CALENDAR_CLEAR_PENDING_ACTION", 0x4BC => "SMSG_EQUIPMENT_SET_LIST", 0x4BD => "CMSG_EQUIPMENT_SET_SAVE", 0x4BE => "CMSG_UPDATE_PROJECTILE_POSITION", 0x4BF => "SMSG_SET_PROJECTILE_POSITION", 0x4C0 => "SMSG_TALENTS_INFO", 0x4C1 => "CMSG_LEARN_PREVIEW_TALENTS", 0x4C2 => "CMSG_LEARN_PREVIEW_TALENTS_PET", 0x4C3 => "CMSG_SET_ACTIVE_TALENT_GROUP_OBSOLETE", 0x4C4 => "CMSG_GM_GRANT_ACHIEVEMENT", 0x4C5 => "CMSG_GM_REMOVE_ACHIEVEMENT", 0x4C6 => "CMSG_GM_SET_CRITERIA_FOR_PLAYER", 0x4C7 => "SMSG_ARENA_UNIT_DESTROYED", 0x4C8 => "SMSG_ARENA_TEAM_CHANGE_FAILED_QUEUED", 0x4C9 => "CMSG_PROFILEDATA_REQUEST", 0x4CA => "SMSG_PROFILEDATA_RESPONSE", 0x4CB => "CMSG_START_BATTLEFIELD_CHEAT", 0x4CC => "CMSG_END_BATTLEFIELD_CHEAT", 0x4CD => "SMSG_MULTIPLE_PACKETS", 0x4CE => "SMSG_MOVE_GRAVITY_DISABLE", 0x4CF => "CMSG_MOVE_GRAVITY_DISABLE_ACK", 0x4D0 => "SMSG_MOVE_GRAVITY_ENABLE", 0x4D1 => "CMSG_MOVE_GRAVITY_ENABLE_ACK", 0x4D2 => "MSG_MOVE_GRAVITY_CHNG", 0x4D3 => "SMSG_SPLINE_MOVE_GRAVITY_DISABLE", 0x4D4 => "SMSG_SPLINE_MOVE_GRAVITY_ENABLE", 0x4D5 => "CMSG_EQUIPMENT_SET_USE", 0x4D6 => "SMSG_EQUIPMENT_SET_USE_RESULT", 0x4D7 => "CMSG_FORCE_ANIM", 0x4D8 => "SMSG_FORCE_ANIM", 0x4D9 => "CMSG_CHAR_FACTION_CHANGE", 0x4DA => "SMSG_CHAR_FACTION_CHANGE", 0x4DB => "CMSG_PVP_QUEUE_STATS_REQUEST", 0x4DC => "SMSG_PVP_QUEUE_STATS", 0x4DD => "CMSG_SET_PAID_SERVICE_CHEAT", 0x4DE => "SMSG_BATTLEFIELD_MGR_ENTRY_INVITE", 0x4DF => "CMSG_BATTLEFIELD_MGR_ENTRY_INVITE_RESPONSE", 0x4E0 => "SMSG_BATTLEFIELD_MGR_ENTERED", 0x4E1 => "SMSG_BATTLEFIELD_MGR_QUEUE_INVITE", 0x4E2 => "CMSG_BATTLEFIELD_MGR_QUEUE_INVITE_RESPONSE", 0x4E3 => "CMSG_BATTLEFIELD_MGR_QUEUE_REQUEST", 0x4E4 => "SMSG_BATTLEFIELD_MGR_QUEUE_REQUEST_RESPONSE", 0x4E5 => "SMSG_BATTLEFIELD_MGR_EJECT_PENDING", 0x4E6 => "SMSG_BATTLEFIELD_MGR_EJECTED", 0x4E7 => "CMSG_BATTLEFIELD_MGR_EXIT_REQUEST", 0x4E8 => "SMSG_BATTLEFIELD_MGR_STATE_CHANGE", 0x4E9 => "CMSG_BATTLEFIELD_MANAGER_ADVANCE_STATE", 0x4EA => "CMSG_BATTLEFIELD_MANAGER_SET_NEXT_TRANSITION_TIME", 0x4EB => "MSG_SET_RAID_DIFFICULTY", 0x4EC => "CMSG_TOGGLE_XP_GAIN", 0x4ED => "SMSG_TOGGLE_XP_GAIN", 0x4EE => "SMSG_GMRESPONSE_DB_ERROR", 0x4EF => "SMSG_GMRESPONSE_RECEIVED", 0x4F0 => "CMSG_GMRESPONSE_RESOLVE", 0x4F1 => "SMSG_GMRESPONSE_STATUS_UPDATE", 0x4F2 => "SMSG_GMRESPONSE_CREATE_TICKET", 0x4F3 => "CMSG_GMRESPONSE_CREATE_TICKET", 0x4F4 => "CMSG_SERVERINFO", 0x4F5 => "SMSG_SERVERINFO", 0x4F6 => "CMSG_WORLD_STATE_UI_TIMER_UPDATE", 0x4F7 => "SMSG_WORLD_STATE_UI_TIMER_UPDATE", 0x4F8 => "CMSG_CHAR_RACE_CHANGE", 0x4F9 => "MSG_VIEW_PHASE_SHIFT", 0x4FA => "SMSG_TALENTS_INVOLUNTARILY_RESET", 0x4FB => "CMSG_DEBUG_SERVER_GEO", 0x4FC => "SMSG_DEBUG_SERVER_GEO", 0x4FD => "SMSG_LOOT_SLOT_CHANGED", 0x4FE => "UMSG_UPDATE_GROUP_INFO", 0x4FF => "CMSG_READY_FOR_ACCOUNT_DATA_TIMES", 0x500 => "CMSG_QUERY_QUESTS_COMPLETED", 0x501 => "SMSG_QUERY_QUESTS_COMPLETED_RESPONSE", 0x502 => "CMSG_GM_REPORT_LAG", 0x503 => "CMSG_AFK_MONITOR_INFO_REQUEST", 0x504 => "SMSG_AFK_MONITOR_INFO_RESPONSE", 0x505 => "CMSG_AFK_MONITOR_INFO_CLEAR", 0x506 => "SMSG_CORPSE_NOT_IN_INSTANCE", 0x507 => "CMSG_GM_NUKE_CHARACTER", 0x508 => "CMSG_SET_ALLOW_LOW_LEVEL_RAID1", 0x509 => "CMSG_SET_ALLOW_LOW_LEVEL_RAID2", 0x50A => "SMSG_CAMERA_SHAKE", 0x50B => "SMSG_SOCKET_GEMS_RESULT", 0x50C => "CMSG_SET_CHARACTER_MODEL", 0x50D => "SMSG_REDIRECT_CLIENT", 0x50E => "CMSG_REDIRECTION_FAILED", 0x50F => "SMSG_SUSPEND_COMMS", 0x510 => "CMSG_SUSPEND_COMMS_ACK", 0x511 => "SMSG_FORCE_SEND_QUEUED_PACKETS", 0x512 => "CMSG_REDIRECTION_AUTH_PROOF", 0x513 => "CMSG_DROP_NEW_CONNECTION", 0x514 => "SMSG_SEND_ALL_COMBAT_LOG", 0x515 => "SMSG_OPEN_LFG_DUNGEON_FINDER", 0x516 => "SMSG_MOVE_SET_COLLISION_HGT", 0x517 => "CMSG_MOVE_SET_COLLISION_HGT_ACK", 0x518 => "MSG_MOVE_SET_COLLISION_HGT", 0x519 => "CMSG_CLEAR_RANDOM_BG_WIN_TIME", 0x51A => "CMSG_CLEAR_HOLIDAY_BG_WIN_TIME", 0x51B => "CMSG_COMMENTATOR_SKIRMISH_QUEUE_COMMAND", 0x51C => "SMSG_COMMENTATOR_SKIRMISH_QUEUE_RESULT1", 0x51D => "SMSG_COMMENTATOR_SKIRMISH_QUEUE_RESULT2", 0x51E => "SMSG_MULTIPLE_MOVES", 
);

my $pkt_fn = $ARGV[0];
my $in_fh;
open $in_fh, "< $pkt_fn" or die "Cannot open $pkt_fn for read!\n";
my $out_fh = *STDOUT;
my $bytes;
my $br;

# LogHeader
#struct LogHeader
#{   
#    char Signature[3];
#    uint16 FormatVersion;
#    uint8 SnifferId;
#    uint32 Build;
#    char Locale[4];
#    uint8 SessionKey[40];
#    uint32 SniffStartUnixtime;
#    uint32 SniffStartTicks;
#    uint32 OptionalDataSize;
#};
print $out_fh "==LogHeader==\n";
dump_field_from_def($in_fh, $out_fh, "char Signature[3];");
dump_field_from_def($in_fh, $out_fh, "uint16 FormatVersion;");
dump_field_from_def($in_fh, $out_fh, "uint8 SnifferId;");
dump_field_from_def($in_fh, $out_fh, "uint32 Build;");
dump_field_from_def($in_fh, $out_fh, "char Locale[4];");
dump_field_from_def($in_fh, $out_fh, "uint8 SessionKey[40];");
dump_field_from_def($in_fh, $out_fh, "uint32 SniffStartUnixtime;");
dump_field_from_def($in_fh, $out_fh, "uint32 SniffStartTicks;");
dump_field_from_def($in_fh, $out_fh, "uint32 OptionalDataSize;");
print $out_fh "==\n\n";

# PacketHeader
#struct PacketHeader
#{
#    // used to uniquely identify a connection
#    struct OptionalData
#    {   
#        uint8 SocketIPBytes[16];
#        uint32 SocketPort;
#    };
#
#    uint32 Direction;
#    uint32 ConnectionId;
#    uint32 ArrivalTicks;
#    uint32 OptionalDataSize;
#    uint32 Length;
#    OptionalData OptionalData;
#    uint32 Opcode;
#};
while (1) {
    print $out_fh "==PacketHeader==\n";
    dump_field_from_def($in_fh, $out_fh, "uint32 Direction;");
    dump_field_from_def($in_fh, $out_fh, "uint32 ConnectionId;");
    dump_field_from_def($in_fh, $out_fh, "uint32 ArrivalTicks;");
    dump_field_from_def($in_fh, $out_fh, "uint32 OptionalDataSize;");
    my $len = dump_field_from_def($in_fh, $out_fh, "uint32 Length;");
    dump_field_from_def($in_fh, $out_fh, "uint8 SocketIPBytes[16];");
    dump_field_from_def($in_fh, $out_fh, "uint32 SocketPort;");
    dump_field_from_def($in_fh, $out_fh, "uint32 Opcode;");
    my $payload_bytes;
    if (read($in_fh, $payload_bytes, ($len-4)) != ($len-4)) {
        exit;
    }
    print $out_fh "==\n\n";
}


sub dump_field_from_def
{
    my ($in_fh, $out_fh, $def_str) = @_;
    my $val;

    if ($def_str =~ /^([^\s]+)\s+([^\s]+);?$/) {
        my $type = $1;
        my $name = $2;
        my $cnt = 1;
        if ($name =~ /\[([0-9]+)\]/) {
            $cnt = $1;
        }
        $val = read_nbytes_parse_as_type($in_fh, $type, $cnt);
        $name =~ s/\;//g;
        if (exists $correction{$name}) {
            $val = $correction{$name}->($val);
        }
        my $str = sprintf("%-32s %s\n", $name, $val);
        print $out_fh $str;
    } else {
        die "dump_field saw invalid: $def_str\n";
    }
    return $val;
}

# Assume read from current position on fh
sub read_nbytes_parse_as_type
{
    my ($in_fh, $type, $cnt) = @_;

    if (not exists $type_parser{$type}) {
        die "Type $type undefined!\n";
    }
    if (not exists $type_size{$type}) {
        die "Type $type size undefined!\n";
    }
    my $br = 0;
    my $bytes;
    my $i = 0;
    my $ret = "";
    while ($i < $cnt) {
        $br = read $in_fh, $bytes, $type_size{$type};
        if ($br != $type_size{$type}) {
            exit;
        }
        $ret = $ret.$type_parser{$type}->($bytes);
        $i = $i + 1;
    }
    return $ret;
}

sub type_char
{
    my ($bytes) = @_;
    my $ret = unpack 'a', $bytes;
    return $ret;
}

sub type_uint8
{
    my ($bytes) = @_;
    my $ret = unpack 'C', $bytes;
    return $ret;
}

sub type_uint16
{
    my ($bytes) = @_;
    my $ret = unpack 'S', $bytes;
    return $ret;
}

sub type_uint32
{
    my ($bytes) = @_;
    my $ret = unpack 'L', $bytes;
    return $ret;
}

sub correct_direction
{
    my ($direction) = @_;
    my $ret = "NA";

    if ($direction == Math::BigInt->new("0x47534d43")) {
        $ret = "C->S";
    } elsif ($direction == Math::BigInt->new("0x47534d53")) {
        $ret = "S->C";
    }
    return $ret;
}

sub decode_opcode
{
    my ($opc) = @_;
    my $ret = "NA";

    if (exists $opcode{$opc}) {
        $ret = $opcode{$opc};
    }
    return $ret;
}

exit;

my $relocInfo_sz = 2;
my $lg_H = 6;
my $H = 1<<$lg_H;
my $BitsPerByte = 8;
my $L = (1<<$BitsPerByte)-$H;
my $MAX_i = 4;
my $type_mask_in_place = (1<<5)-1;
my $LOCATION_CODE = 0;
my $CONSTANT_INT_CODE = 1;
my $CONSTANT_OOP_CODE = 2;
my $CONSTANT_LONG_CODE = 3;
my $CONSTANT_DOUBLE_CODE = 4;
my $OBJECT_CODE = 5;
my $OBJECT_ID_CODE = 6;
my $input_fn = $ARGV[0];
my $output_fn = $input_fn.".txt";
if ($#ARGV > 0) {
  $output_fn = $ARGV[1];
}
#my $in_fh;
#my $out_fh;
open $in_fh, "< $input_fn" or die "Cannot open $input_fn for read!\n";
open $out_fh, "> $output_fn" or die "Cannot open $output_fn for write!\n";
#my $bytes;
#my $br = 0;
my $value_width = 2*8;
my $type_width = 4;
my $nontype_width = $value_width - $type_width;
my $datalen_width = $nontype_width-1;
my $datalen_tag = 1 << $datalen_width;
my $datalen_limit = 1 << $datalen_width;
my $datalen_mask = (1 << $datalen_width)-1;
my $format_width = 1;
my $offset_unit = 4;
my $offset_width = $nontype_width-$format_width;
my $offset_mask = (1<<$offset_width)-1;
my $format_mask = (1<<$format_width)-1;

# Methods
while (1) {
  my $cnt = 0;
  $br = read $in_fh, $bytes, 4;
  exit unless $br == 4;
  
  my $magic = unpack 'a4', $bytes;
  if ($magic eq "ERRO") {
    print $out_fh "\nERROR due to class byte code retransform/redefine\n";
    exit;
  }
  if ($magic eq "JITB") {
    my $hash_bin = read $in_fh, $bytes, 8;
    exit unless $hash_bin == 8;
    my $method_hash = unpack 'L', $bytes;
    $br = read $in_fh, $bytes, 4;
    exit unless $br == 4;
    my $method_sz = unpack 'I', $bytes;
    $br = read $in_fh, $bytes, $method_sz;
    exit unless $br == $method_sz;
    my ($space, $length) = unpack 'v v', $bytes;
    $cnt = 2+2;
    $length = $length-1;
    my $method_name = unpack "x$cnt a$length", $bytes;
    $cnt = $cnt+$space;
    print $out_fh "============================================\n";
    print $out_fh "method_name: $method_name\n";
    print $out_fh "hash: $method_hash\n";
    my $compile_id = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "compile_id: $compile_id\n";
    my $entry_bci = unpack "x$cnt i", $bytes;
    $cnt = $cnt+4;
    print $out_fh "entry_bci: $entry_bci\n";
    # CodeOffsets::max_Entries
    my $entries = unpack "x$cnt i", $bytes;
    $cnt = $cnt+4;
    print $out_fh "  Entry: $entries\n";
    $entries = unpack "x$cnt i", $bytes;
    $cnt = $cnt+4;
    print $out_fh "  Verified_Entry: $entries\n";
    $entries = unpack "x$cnt i", $bytes;
    $cnt = $cnt+4;
    print $out_fh "  Frame_Complete: $entries\n";
    $entries = unpack "x$cnt i", $bytes;
    $cnt = $cnt+4;
    print $out_fh "  OSR_Entry: $entries\n";
    $entries = unpack "x$cnt i", $bytes;
    $cnt = $cnt+4;
    print $out_fh "  Exceptions: $entries\n";
    $entries = unpack "x$cnt i", $bytes;
    $cnt = $cnt+4;
    print $out_fh "  Deopt: $entries\n";
    $entries = unpack "x$cnt i", $bytes;
    $cnt = $cnt+4;
    print $out_fh "  DeoptMH: $entries\n";
    $entries = unpack "x$cnt i", $bytes;
    $cnt = $cnt+4;
    print $out_fh "  UnwindHandler: $entries\n";
    # orig_pc_offset
    my $orig_pc_offset = unpack "x$cnt i", $bytes;
    $cnt = $cnt+4;
    print $out_fh "orig_pc_offset: $orig_pc_offset\n";
    # DebugInformationRecorder
    my $scopes_data_space = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    my $scopes_data_length = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    #print $out_fh "DebugInformationRecorder.scopes_data: ";
    my $idx = 0;
    my $cnt_tmp;
    my @scopes_data = ();
    while ($idx < $scopes_data_length) {
      $cnt_tmp = $cnt+$idx;
      my $c_value = unpack "x$cnt_tmp C", $bytes;
      push @scopes_data, $c_value;
      my $output = sprintf("%02X", $c_value);
      #print $out_fh "$output";
      $idx = $idx+1;
    }
    #print $out_fh "\n";
    $cnt = $cnt+$scopes_data_space;
    my $scopes_pcs_cnt = unpack "x$cnt v", $bytes;
    $cnt = $cnt+2;
    print $out_fh "DebugInformationRecorder.scopes_pcs\n  Count: $scopes_pcs_cnt\n";
    my $scope_idx = 0;
    while ($scope_idx < $scopes_pcs_cnt) {
      my $pcs_offset = unpack "x$cnt i", $bytes;
      $cnt = $cnt+4;
      print $out_fh "    _pcs_offset: $pcs_offset ";
      my $scope_decode_offset = unpack "x$cnt i", $bytes;
      $cnt = $cnt+4;
      #print $out_fh "_scope_decode_offset: $scope_decode_offset ";
      my $obj_decode_offset = unpack "x$cnt i", $bytes;
      $cnt = $cnt+4;
      #print $out_fh "_obj_decode_offset: $obj_decode_offset ";
      my $flags = unpack "x$cnt i", $bytes;
      $cnt = $cnt+4;
      print $out_fh "_flags: ";
      if ($flags != 0) {
        if ($flags & 1) {
          print $out_fh "should_reexec/";
        }
        if ($flags & 2) {
          print $out_fh "is_MH_invoke/";
        }
        if ($flags & 4) {
          print $out_fh "return_oop";
        }
      }
      #print $out_fh "\n";
      # Decode scopes data
      if ($scope_decode_offset != 0) {
        my $pos = $scope_decode_offset;
        my ($sender_stream_offset, $oop_rec_metadata_idx, $bci, $locals, $expressions, $monitors, $new_pos);
        ($sender_stream_offset, $new_pos) = read_int(\@scopes_data, $pos);
        $pos = $new_pos;
        ($oop_rec_metadata_idx, $new_pos) = read_int(\@scopes_data, $pos);
        $pos = $new_pos;
        ($bci, $new_pos) = read_bci(\@scopes_data, $pos);    
        $pos = $new_pos;
        ($locals, $new_pos) = read_int(\@scopes_data, $pos);
        $pos = $new_pos;
        ($expressions, $new_pos) = read_int(\@scopes_data, $pos);
        $pos = $new_pos;
        ($monitors, $new_pos) = read_int(\@scopes_data, $pos);
        $pos = $new_pos;
        print $out_fh " sender_stream_offset$sender_stream_offset/oop_rec_metadata_idx$oop_rec_metadata_idx/bci$bci ";
        if ($locals != 0) {
          print $out_fh "locals";
          my $val_len;
          ($val_len, $new_pos) = read_int(\@scopes_data, $locals);
          $pos = $new_pos;
          print $out_fh "($val_len) ";
          my $idx = 0;
          while ($idx < $val_len) {
            my @sv = parse_scope_value(\@scopes_data, $pos);
            $pos = $sv[@sv-1];
            my $idx2 = 0;
            while ($idx2 < @sv-2) {
              print $out_fh "$sv[$idx2]/";
              $idx2 = $idx2+1;
            }
            print $out_fh "$sv[$idx2];;";
            $idx = $idx+1;
          }
        }
        if ($expressions != 0) {
          print $out_fh " expressions";
          my $val_len;
          ($val_len, $new_pos) = read_int(\@scopes_data, $expressions);
          $pos = $new_pos;
          print $out_fh "($val_len) ";
          my $idx = 0;
          while ($idx < $val_len) {
            my @sv = parse_scope_value(\@scopes_data, $pos);
            $pos = $sv[@sv-1];
            my $idx2 = 0;
            while ($idx2 < @sv-2) {
              print $out_fh "$sv[$idx2]/";
              $idx2 = $idx2+1;
            }
            print $out_fh "$sv[$idx2];;";
            $idx = $idx+1;
          }
        }
        if ($monitors != 0) {
          print $out_fh " monitors";
          my $val_len;
          ($val_len, $new_pos) = read_int(\@scopes_data, $monitors);
          $pos = $new_pos;
          print $out_fh "($val_len) ";
          my $idx = 0;
          while ($idx < $val_len) {
            my @sv = parse_monitor_value(\@scopes_data, $pos);
            $pos = $sv[@sv-1];
            my $idx2 = 0;
            while ($idx2 < @sv-2) {
              print $out_fh "$sv[$idx2]/";
              $idx2 = $idx2+1;
            }
            print $out_fh "$sv[$idx2];;";
            $idx = $idx+1;
          }
        }
      }
      if ($obj_decode_offset != 0) {
        print $out_fh " obj";
        my ($val_len, $new_pos, $pos);
        ($val_len, $new_pos) = read_int(\@scopes_data, $obj_decode_offset);
        $pos = $new_pos;
        print $out_fh "($val_len) ";
        my $idx = 0;
        while ($idx < $val_len) {
          my @sv = parse_scope_value(\@scopes_data, $pos);
          $pos = $sv[@sv-1];
          my $idx2 = 0;
          while ($idx2 < @sv-2) {
            print $out_fh "$sv[$idx2]/";
            $idx2 = $idx2+1;
          }
          print $out_fh "$sv[$idx2];;";
          $idx = $idx+1;
        }
      }
      print $out_fh "\n";
      $scope_idx = $scope_idx+1;
    }
    # Dependencies
    my $size_in_bytes = unpack "x$cnt q", $bytes;
    $cnt = $cnt+8;
    #print $out_fh "Dependencies.size_in_bytes: $size_in_bytes\n";
    $space = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "Dependencies:\n";
    $idx = 0;
    my @dep = ();
    while ($idx < $size_in_bytes) {
      $cnt_tmp = $cnt+$idx;
      my $c_value = unpack "x$cnt_tmp C", $bytes;
      push @dep, $c_value;
      my $output = sprintf("%02X", $c_value);
      #print $out_fh "$output";
      $idx = $idx+1;
    }
    #print $out_fh "\n";
    $cnt = $cnt+$space;
  
    $idx = 0;
    my $dep_c = 0;
    while ($idx < @dep) {
      my ($val, $new_idx) = read_b(\@dep, $idx);
      $idx = $new_idx;
      if ($val == 0) {
        print $out_fh "  end_marker\n";
        last;
      } else {
        #print $out_fh "  read_b: $val ";
        my $ctxk_bit = ($val & (1<<4));
        my ($dep_type, $stride) = parse_dep_type($val - $ctxk_bit);
        print $out_fh "  $dep_type ";
        my $skipj = -1;
        if ($ctxk_bit != 0) {
          $skipj = 0;
        }
        my $i = 0;
        while ($i < $stride) {
          if ($i == $skipj) {
            print $out_fh "0 ";
          } else {
            my ($v, $new_idx) = read_int(\@dep, $idx);
            $idx = $new_idx;
            print $out_fh "$v ";
          }
          $i = $i + 1;
        }
        print $out_fh "\n";
      }
    }
  
    # CodeBuffer
    print $out_fh "CodeBuffer\n";
    my $total_relocation_size = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "  total_relocation_size: $total_relocation_size\n";
    my $total_offset_of_insts = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "  total_offset_of_insts: $total_offset_of_insts\n";
    my $total_offset_of_consts = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "  total_offset_of_consts: $total_offset_of_consts\n";
    my $total_offset_of_stubs = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "  total_offset_of_stubs: $total_offset_of_stubs\n";
    my $total_content_size = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "  total_content_size: $total_content_size\n";
    # CodeBuffer::consts
    $cnt = code_section($bytes, $cnt, "consts");
    # CodeBuffer::insts
    $cnt = code_section($bytes, $cnt, "insts");
    # CodeBuffer::stubs
    $cnt = code_section($bytes, $cnt, "stubs");
    # OopRecorder
    my $oop_rec_is_unused = unpack "x$cnt C", $bytes;
    $cnt = $cnt+1;
    print $out_fh "OopRecorder.is_unused: $oop_rec_is_unused\n";
    my $oops_is_unused = unpack "x$cnt C", $bytes;
    $cnt = $cnt+1;
    print $out_fh "  oops.is_unused: $oops_is_unused\n";
    my $count = 0;
    if ($oops_is_unused == 0) {
      $count = unpack "x$cnt v", $bytes;
      $cnt = $cnt+2;
      print $out_fh "  oops.handles_count: $count\n";
      $idx = 0;
      while ($idx < $count) {
        my $oops_handle = unpack "x$cnt Q", $bytes;
        $cnt = $cnt+8;
        print $out_fh "    $oops_handle\n";
        $idx = $idx+1;
      }
    }
    my $metadata_is_unused = unpack "x$cnt C", $bytes;
    $cnt = $cnt+1;
    print $out_fh "  metadata.is_unused: $metadata_is_unused\n";
    if ($metadata_is_unused == 0) {
      $count = unpack "x$cnt v", $bytes;
      $cnt = $cnt+2;
      print $out_fh "  metadata.handles_count: $count\n";
      $idx = 0;
      while ($idx < $count) {
        my $metadata_handle = unpack "x$cnt Q", $bytes;
        $cnt = $cnt+8;
        print $out_fh "    $metadata_handle\n";
        $idx = $idx+1;
      }
    }
    # framesize
    my $frame_size = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "frame_size: $frame_size\n";
    my $oop_map_set_exists = unpack "x$cnt C", $bytes;
    $cnt = $cnt+1;
    if ($oop_map_set_exists != 0) {
      # heap_size/_om_count/_om_size
      my $heap_size = unpack "x$cnt I", $bytes;
      $cnt = $cnt+4;
      print $out_fh "OopMapSet\n  heap_size: $heap_size\n";
      my $om_count = unpack "x$cnt I", $bytes;
      $cnt = $cnt+4;
      print $out_fh "  om_count: $om_count\n";
      my $om_size = unpack "x$cnt I", $bytes;
      $cnt = $cnt+4;
      print $out_fh "  om_size: $om_size\n";
      $count = 0;
      while ($count < $om_count) {
        my $pc_offset = unpack "x$cnt i", $bytes;
        $cnt = $cnt+4;
        print $out_fh "    pc_offset: $pc_offset ";
  
        my $omv_count = unpack "x$cnt i", $bytes;
        $cnt = $cnt+4;
        print $out_fh "omv_count: $omv_count ";
  
        my $omv_data_size = unpack "x$cnt i", $bytes;
        $cnt = $cnt+4;
        print $out_fh "omv_data_size: $omv_data_size ";
  
        my $omv_data_space = unpack "x$cnt I", $bytes;
        $cnt = $cnt+4;
        my $omv_data_length = unpack "x$cnt I", $bytes;
        $cnt = $cnt+4;
        $idx = 0;
        print $out_fh "omv_data: ";
        my @omv_data = ();
        while ($idx < $omv_data_length) {
          $cnt_tmp = $cnt+$idx;
          my $c_value = unpack "x$cnt_tmp C", $bytes;
          push @omv_data, $c_value;
          my $output = sprintf("%02X", $c_value);
          #print $out_fh "$output";
          $idx = $idx+1;
        }
        #print $out_fh " ";
        $cnt = $cnt+$omv_data_space;
  
        # Parse the omv_data
        my $pos = 0;
        my $omv_c = 0;
        while ($pos < @omv_data and $omv_c < $omv_count) {
          my ($val, $new_pos) = read_int(\@omv_data, $pos);
          $pos = $new_pos;
          my $need_read_int = 0;
          my $show_val = $val>>5;
          print $out_fh "/$show_val ";
          if (($val & $type_mask_in_place) == 1) {
            print $out_fh "is_oop ";
          }
          if (($val & $type_mask_in_place) == 2) {
            print $out_fh "is_value ";
          }
          if (($val & $type_mask_in_place) == 4) {
            print $out_fh "is_narrowoop ";
          }
          if (($val & $type_mask_in_place) == 8) {
            $need_read_int = 1;
            print $out_fh "is_callee_saved ";
          } 
          if (($val & $type_mask_in_place) == 16) {
            $need_read_int = 1;
            print $out_fh "is_derived_oop ";
          }
          if ($need_read_int == 1) {
            ($val, $new_pos) = read_int(\@omv_data, $pos);
            $show_val = $val>>5;
            print $out_fh "reg$show_val";
          }
          $omv_c = $omv_c+1;
        }
  
        $heap_size = unpack "x$cnt i", $bytes;
        $cnt = $cnt+4;
        print $out_fh " heap_size: $heap_size\n";
  
        $count = $count+1;
      }
    }
    # ExceptionHandlerTable
    my $exp_size_in_bytes = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "ExceptionHandlerTable.size_in_bytes: $exp_size_in_bytes\n";
    my $exp_table_space = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    my $exp_table_length = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    $idx = 0;
    $cnt_tmp = $cnt+$idx;
    print $out_fh "ExceptionHandlerTable.table:\n";
    while ($idx < $exp_table_length) {
      my $c_value = unpack "x$cnt_tmp I", $bytes;
      if ($c_value == 4294967295) {
        print $out_fh "  bci:-1 ";
      } else {
        print $out_fh "  bci:$c_value ";
      }
      $idx = $idx+4;
      $cnt_tmp = $cnt+$idx;
      $c_value = unpack "x$cnt_tmp I", $bytes;
      print $out_fh "pco:$c_value ";
      $idx = $idx+4;
      $cnt_tmp = $cnt+$idx;
      $c_value = unpack "x$cnt_tmp I", $bytes;
      print $out_fh "scope_depth:$c_value\n";
      $idx = $idx+4;
      $cnt_tmp = $cnt+$idx;
    }
    $cnt = $cnt+$exp_table_space;
    # ImplicitExceptionTable
    my $imp_size_in_bytes = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "ImplicitExceptionTable.size_in_bytes: $imp_size_in_bytes\n";
    my $imp_data_space = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    my $imp_data_length = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    $idx = 0;
    print $out_fh "ImplicitExceptionTable.data:\n";
    if ($imp_size_in_bytes > 0) {
      my $imp_cnt = ($imp_size_in_bytes-4)/8;
      while ($idx < $imp_cnt) {
        $cnt_tmp = $cnt+$idx*8;
        my $c_value = unpack "x$cnt_tmp I", $bytes;
        print $out_fh "  exception-offset $c_value ";
        $cnt_tmp = $cnt+$idx*8+4;
        $c_value = unpack "x$cnt_tmp I", $bytes;
        print $out_fh "continue-offset $c_value\n";
        $idx = $idx+1;
      }
    }
    $cnt = $cnt+$imp_data_space;
    my $imp_len = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "ImplicitExceptionTable.len: $imp_len\n";
    my $comp_level = unpack "x$cnt v", $bytes;
    $cnt = $cnt+2;
    print $out_fh "comp_level: $comp_level\n";
    my $nmethod_alloc_size = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "nmethod.allocation_size: $nmethod_alloc_size\n";
    # DebugInformationRecorder
    my $pcs_size = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "DebugInformationRecorder.pcs_size: $pcs_size\n";
    my $data_size = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "DebugInformationRecorder.data_size: $data_size\n";
    # CodeBuffer
    my $total_oop_size = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "CodeBuffer.total_oop_size: $total_oop_size\n";
    my $total_metadata_size = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "CodeBuffer.total_metadata_size: $total_metadata_size  \n";
  
    # misc
    my $has_unsafe_access = unpack "x$cnt C", $bytes;
    $cnt = $cnt+1;
    print $out_fh "has_unsafe_access: $has_unsafe_access\n";
    my $has_wide_vectors = unpack "x$cnt C", $bytes;
    $cnt = $cnt+1;
    print $out_fh "has_wide_vectors: $has_wide_vectors\n\n";
  
    if ($cnt != $method_sz) {
      die "Method data format error!\n";
    }
  } elsif ($magic eq "JITN") {
    my $idx = 0;
    my $hash_bin = read $in_fh, $bytes, 8;
    exit unless $hash_bin == 8;
    my $method_hash = unpack 'L', $bytes;
    $br = read $in_fh, $bytes, 4;
    exit unless $br == 4;
    my $method_sz = unpack 'I', $bytes;
    $br = read $in_fh, $bytes, $method_sz;
    exit unless $br == $method_sz;
    my ($space, $length) = unpack 'v v', $bytes;
    $cnt = 2+2;
    $length = $length-1;
    my $method_name = unpack "x$cnt a$length", $bytes;
    $cnt = $cnt+$space;
    print $out_fh "++++++++++++++++++++++++++++++++++++++++++++\n";
    print $out_fh "method_name: $method_name\n";
    print $out_fh "hash: $method_hash\n";
    my $entry_offset = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "entry_point_offset: $entry_offset\n";
    my $verified_entry_offset = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "verified_entry_point_offset: $verified_entry_offset\n";
    my $exception_offset = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "exception_offset: $exception_offset\n";
    my $deoptimize_offset = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "deoptimize_offset: $deoptimize_offset\n";
    my $deopt_mh_offset = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "deopt_mh_offset: $deopt_mh_offset\n";
    my $unwind_handler_offset = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "unwind_handler_offset: $unwind_handler_offset\n";
    my $consts_offset = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "consts_offset: $consts_offset\n";
    my $stub_offset = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "stub_offset: $stub_offset\n";
    my $oops_offset = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "oops_offset: $oops_offset\n";
    my $metadata_offset = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "metadata_offset: $metadata_offset\n";
    my $scopes_data_offset = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "scopes_data_offset: $scopes_data_offset\n";
    my $scopes_pcs_offset = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "scopes_pcs_offset: $scopes_pcs_offset\n";
    my $dependencies_offset = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "dependencies_offset: $dependencies_offset\n";
    my $handler_table_offset = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "handler_table_offset: $handler_table_offset\n";
    my $nul_chk_table_offset = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "nul_chk_table_offset: $nul_chk_table_offset\n";
    my $nmethod_end_offset = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "nmethod_end_offset: $nmethod_end_offset\n";
    my $orig_oc_offset = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "orig_oc_offset: $orig_oc_offset\n";
    my $compile_id = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "compile_id: $compile_id\n";
    my $comp_level = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "comp_level: $comp_level\n";
    my $size = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "size: $size\n";
    my $header_size = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "header_size: $header_size\n";
    my $relocation_size = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "relocation_size: $relocation_size\n";
    my $content_offset = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "content_offset: $content_offset\n";
    my $code_offset = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "code_offset: $code_offset\n";
    my $frame_complete_offset = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    if ($frame_complete_offset == 4294967295) {
      $frame_complete_offset = -1;
    }
    print $out_fh "frame_complete_offset: $frame_complete_offset\n";
    my $data_offset = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "data_offset: $data_offset\n";
    my $frame_size = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "frame_size: $frame_size\n";
    my $oop_map_set_exists = unpack "x$cnt C", $bytes;
    $cnt = $cnt+1;
    if ($oop_map_set_exists != 0) {
      # heap_size/_om_count/_om_size
      my $om_count = unpack "x$cnt I", $bytes;
      $cnt = $cnt+4;
      print $out_fh "OopMapSet\n  om_count: $om_count\n";
      my $om_size = unpack "x$cnt I", $bytes;
      if ($om_size == 4294967295) {
        $om_size = -1;
      }
      $cnt = $cnt+4;
      print $out_fh "  om_size: $om_size\n";
      my $count = 0;
      while ($count < $om_count) {
        my $pc_offset = unpack "x$cnt i", $bytes;
        $cnt = $cnt+4;
        print $out_fh "    pc_offset: $pc_offset ";
  
        my $omv_count = unpack "x$cnt i", $bytes;
        $cnt = $cnt+4;
        print $out_fh "omv_count: $omv_count ";
  
        my $omv_data_size = unpack "x$cnt i", $bytes;
        $cnt = $cnt+4;
        print $out_fh "omv_data_size: $omv_data_size ";
  
        my $omv_data_space = unpack "x$cnt I", $bytes;
        $cnt = $cnt+4;
        my $omv_data_length = unpack "x$cnt I", $bytes;
        $cnt = $cnt+4;
        $idx = 0;
        print $out_fh "omv_data: ";
        my @omv_data = ();
        my $cnt_tmp = 0;
        while ($idx < $omv_data_length) {
          $cnt_tmp = $cnt+$idx;
          my $c_value = unpack "x$cnt_tmp C", $bytes;
          push @omv_data, $c_value;
          my $output = sprintf("%02X", $c_value);
          #print $out_fh "$output";
          $idx = $idx+1;
        }
        #print $out_fh " ";
        $cnt = $cnt+$omv_data_space;
  
        # Parse the omv_data
        my $pos = 0;
        my $omv_c = 0;
        while ($pos < @omv_data and $omv_c < $omv_count) {
          my ($val, $new_pos) = read_int(\@omv_data, $pos);
          $pos = $new_pos;
          my $need_read_int = 0;
          my $show_val = $val>>5;
          print $out_fh "/$show_val ";
          if (($val & $type_mask_in_place) == 1) {
            print $out_fh "is_oop ";
          }
          if (($val & $type_mask_in_place) == 2) {
            print $out_fh "is_value ";
          }
          if (($val & $type_mask_in_place) == 4) {
            print $out_fh "is_narrowoop ";
          }
          if (($val & $type_mask_in_place) == 8) {
            $need_read_int = 1;
            print $out_fh "is_callee_saved ";
          } 
          if (($val & $type_mask_in_place) == 16) {
            $need_read_int = 1;
            print $out_fh "is_derived_oop ";
          }
          if ($need_read_int == 1) {
            ($val, $new_pos) = read_int(\@omv_data, $pos);
            $show_val = $val>>5;
            print $out_fh "reg$show_val";
          }
          $omv_c = $omv_c+1;
        }
        $count = $count+1;
        print $out_fh "\n";
      }
    } else {
      print $out_fh "OopMapSet NULL\n";
    }
    my $insts_addr = unpack "x$cnt Q", $bytes;
    $cnt = $cnt+8;
    my $insts_addr_hex = sprintf "%x", $insts_addr;
    print $out_fh "Insts address: $insts_addr_hex\n";
    my $code_size = unpack "x$cnt I", $bytes;
    $cnt = $cnt+4;
    print $out_fh "CodeSize: $code_size\n";

    my $cnt_tmp;
    my @code_data = ();
    $idx = 0;
    while ($idx < $code_size) {
      $cnt_tmp = $cnt+$idx;
      my $c_value = unpack "x$cnt_tmp C", $bytes;
      push @code_data, $c_value;
      my $output = sprintf("%02X", $c_value);
      print $out_fh "$output";
      $idx = $idx+1;
    }
    print $out_fh "\n";
    #$cnt = $cnt+$code_size;

    # Parse CodeData
    # relocInfo
    my $reloc_ptr = 0;
    my $total_offset = 0;
    print $out_fh "RelocInfo\n";
    my $reloc_address = $insts_addr - $code_offset + $header_size;
    while ($reloc_ptr < $relocation_size) {
      my $cnt_tmp = $cnt+$reloc_ptr;
      my $value = unpack "x$cnt_tmp S", $bytes;
      my $type = $value >> $nontype_width;
      my $format = $format_mask & ($value>>$offset_width);
      if ($type <= 14) {
        my $type_str = sprintf "%-24s", int2reloc_type($type);
        my $offset = ($value & $offset_mask)*$offset_unit;
        $total_offset = $total_offset+$offset;
        my $t_offset_str = sprintf "%x", $total_offset;
        my $reloc_addr_hex = sprintf "%x", ($reloc_address + $reloc_ptr);
        print $out_fh "    $type_str, format/$format, t_offset $t_offset_str relocInfo:$reloc_addr_hex\n";
      } elsif ($type == 15) {
        my $is_immediate_flag = $value & $datalen_tag;
        my $type_str = sprintf "%-24s", "data_prefix_tag";
        print $out_fh "    $type_str, format/$format, ";
        if ($is_immediate_flag == 0) {
          my $immediate = $value & $datalen_mask;
          print $out_fh "immediate:$immediate ";
        } else {
          my $datalen = $value & $datalen_mask;
          print $out_fh "datalen:$datalen ";
          my $datalen_cnt = $cnt+$reloc_ptr+$relocInfo_sz;
          $datalen = $datalen*2;
          $idx = 0;
          while ($idx < $datalen) {
            my $c_value = unpack "x$datalen_cnt C", $bytes;
            my $output = sprintf("%02x", $c_value);
            print $out_fh "$output";
            $idx = $idx+1;
            $datalen_cnt = $datalen_cnt+1;
          }
          $reloc_ptr = $reloc_ptr+$datalen;
        }
        print $out_fh "\n";
      } else {
        die "BUG";
      }
      $reloc_ptr = $reloc_ptr+$relocInfo_sz;
    }
    print $out_fh "RelocInfo binary:\n";
    $idx = 0;
    while ($idx < $relocation_size) {
      $cnt_tmp = $cnt+$idx;
      my $c_value = unpack "x$cnt_tmp C", $bytes;
      my $output = sprintf("%02x", $c_value);
      print $out_fh "$output";
      $idx = $idx+1;
    }
    print $out_fh "\n";
    $cnt = $cnt+$relocation_size;
    if ($content_offset < ($header_size + $relocation_size)) {
      die "JITN method:$method_name error: content_offset($content_offset) < (header_size($header_size)+relocation_size($relocation_size))!\n";
    }
    if ($content_offset > ($header_size + $relocation_size)) {
      print $out_fh "Gap between relocInfo and content:\n";
      $idx = 0;
      while ($idx < ($content_offset - ($header_size + $relocation_size))) {
        $cnt_tmp = $cnt+$idx;
        my $c_value = unpack "x$cnt_tmp C", $bytes;
        my $output = sprintf("%02X", $c_value);
        print $out_fh "$output";
        $idx = $idx+1;
      }
      print $out_fh "\n";
      $cnt = $cnt + ($content_offset - ($header_size + $relocation_size));
    }
    
    # Constant section with padding
    print $out_fh "Consts with padding:\n";
    $idx = 0;
    while ($idx < ($code_offset - $content_offset)) {
      $cnt_tmp = $cnt+$idx;
      my $l_value = unpack "x$cnt_tmp Q", $bytes;
      my $l_idx = sprintf "%03x", $idx;
      my $l_str = sprintf "%x", $l_value;
      print $out_fh "  $l_idx: $l_str\n";
      $idx = $idx+8;
    }
    $cnt = $cnt + ($code_offset - $content_offset);

    # Code section (insts)
    print $out_fh "Insts + Stubs:\n";
    my $bin_data = substr $bytes, $cnt, ($data_offset - $code_offset);
    open(my $out, '>:raw', 'sample.bin') or die "Unable to open: $!";
    print $out $bin_data;
    close($out);
    my @disassemble = split /\n/, `objdump -mpowerpc:common64 -D -b binary sample.bin`;
    $idx = 6;
    while ($idx <= $#disassemble) {
      print $out_fh "$disassemble[$idx]\n";
      $idx = $idx+1;
    }
    print $out_fh "\n";
    `rm -f sample.bin`;
    $cnt = $cnt + ($data_offset - $code_offset);

    # Oops
    print $out_fh "Oops:\n";
    $idx = 0;
    while ($idx < ($metadata_offset - $oops_offset)) {
      $cnt_tmp = $cnt+$idx;
      my $l_value = unpack "x$cnt_tmp Q", $bytes;
      my $l_str = sprintf "%x", $l_value;
      print $out_fh "  $l_str\n";
      $idx = $idx+8;
    }
    $cnt = $cnt + ($metadata_offset - $oops_offset);

    # Metadata
    print $out_fh "Metadata:\n";
    $idx = 0;
    while ($idx < ($scopes_data_offset - $metadata_offset)) {
      $cnt_tmp = $cnt+$idx;
      my $l_value = unpack "x$cnt_tmp Q", $bytes;
      my $l_str = sprintf "%x", $l_value;
      print $out_fh "  $l_str\n";
      $idx = $idx+8;
    }
    $cnt = $cnt + ($scopes_data_offset - $metadata_offset);

    # Scopes_data
    my @scopes_data = ();
    $idx = 0;
    while ($idx < ($scopes_pcs_offset - $scopes_data_offset)) {
      $cnt_tmp = $cnt+$idx;
      my $c_value = unpack "x$cnt_tmp C", $bytes;
      push @scopes_data, $c_value;
      my $output = sprintf("%02X", $c_value);
      $idx = $idx+1;
    }
    $cnt = $cnt + ($scopes_pcs_offset - $scopes_data_offset);

    # Scopes_pcs
    print $out_fh "Scope PCS:\n";
    $idx = 0;
    while ($idx < ($dependencies_offset - $scopes_pcs_offset)) {
      $cnt_tmp = $cnt+$idx;
      my $pcs_offset = unpack "x$cnt_tmp i", $bytes;
      $idx = $idx+4;
      print $out_fh "    _pcs_offset: $pcs_offset ";
      $cnt_tmp = $cnt+$idx;
      my $scope_decode_offset = unpack "x$cnt_tmp i", $bytes;
      $idx = $idx+4;
      #print $out_fh "_scope_decode_offset: $scope_decode_offset ";
      $cnt_tmp = $cnt+$idx;
      my $obj_decode_offset = unpack "x$cnt_tmp i", $bytes;
      $idx = $idx+4;
      #print $out_fh "_obj_decode_offset: $obj_decode_offset ";
      $cnt_tmp = $cnt+$idx;
      my $flags = unpack "x$cnt_tmp i", $bytes;
      $idx = $idx+4;
      print $out_fh "_flags: ";
      if ($flags != 0) {
        if ($flags & 1) {
          print $out_fh "should_reexec/";
        }
        if ($flags & 2) {
          print $out_fh "is_MH_invoke/";
        }
        if ($flags & 4) {
          print $out_fh "return_oop";
        }
      }
      #print $out_fh "\n";
      # Decode scopes data
      if ($scope_decode_offset != 0) {
        my $pos = $scope_decode_offset;
        my ($sender_stream_offset, $oop_rec_metadata_idx, $bci, $locals, $expressions, $monitors, $new_pos);
        ($sender_stream_offset, $new_pos) = read_int(\@scopes_data, $pos);
        $pos = $new_pos;
        ($oop_rec_metadata_idx, $new_pos) = read_int(\@scopes_data, $pos);
        $pos = $new_pos;
        ($bci, $new_pos) = read_bci(\@scopes_data, $pos);    
        $pos = $new_pos;
        ($locals, $new_pos) = read_int(\@scopes_data, $pos);
        $pos = $new_pos;
        ($expressions, $new_pos) = read_int(\@scopes_data, $pos);
        $pos = $new_pos;
        ($monitors, $new_pos) = read_int(\@scopes_data, $pos);
        $pos = $new_pos;
        print $out_fh " sender_stream_offset$sender_stream_offset/oop_rec_metadata_idx$oop_rec_metadata_idx/bci$bci ";
        if ($locals != 0) {
          print $out_fh "locals";
          my $val_len;
          ($val_len, $new_pos) = read_int(\@scopes_data, $locals);
          $pos = $new_pos;
          print $out_fh "($val_len) ";
          my $idx = 0;
          while ($idx < $val_len) {
            my @sv = parse_scope_value(\@scopes_data, $pos);
            $pos = $sv[@sv-1];
            my $idx2 = 0;
            while ($idx2 < @sv-2) {
              print $out_fh "$sv[$idx2]/";
              $idx2 = $idx2+1;
            }
            print $out_fh "$sv[$idx2];;";
            $idx = $idx+1;
          }
        }
        if ($expressions != 0) {
          print $out_fh " expressions";
          my $val_len;
          ($val_len, $new_pos) = read_int(\@scopes_data, $expressions);
          $pos = $new_pos;
          print $out_fh "($val_len) ";
          my $idx = 0;
          while ($idx < $val_len) {
            my @sv = parse_scope_value(\@scopes_data, $pos);
            $pos = $sv[@sv-1];
            my $idx2 = 0;
            while ($idx2 < @sv-2) {
              print $out_fh "$sv[$idx2]/";
              $idx2 = $idx2+1;
            }
            print $out_fh "$sv[$idx2];;";
            $idx = $idx+1;
          }
        }
        if ($monitors != 0) {
          print $out_fh " monitors";
          my $val_len;
          ($val_len, $new_pos) = read_int(\@scopes_data, $monitors);
          $pos = $new_pos;
          print $out_fh "($val_len) ";
          my $idx = 0;
          while ($idx < $val_len) {
            my @sv = parse_monitor_value(\@scopes_data, $pos);
            $pos = $sv[@sv-1];
            my $idx2 = 0;
            while ($idx2 < @sv-2) {
              print $out_fh "$sv[$idx2]/";
              $idx2 = $idx2+1;
            }
            print $out_fh "$sv[$idx2];;";
            $idx = $idx+1;
          }
        }
      }
      if ($obj_decode_offset != 0) {
        print $out_fh " obj";
        my ($val_len, $new_pos, $pos);
        ($val_len, $new_pos) = read_int(\@scopes_data, $obj_decode_offset);
        $pos = $new_pos;
        print $out_fh "($val_len) ";
        my $idx = 0;
        while ($idx < $val_len) {
          my @sv = parse_scope_value(\@scopes_data, $pos);
          $pos = $sv[@sv-1];
          my $idx2 = 0;
          while ($idx2 < @sv-2) {
            print $out_fh "$sv[$idx2]/";
            $idx2 = $idx2+1;
          }
          print $out_fh "$sv[$idx2];;";
          $idx = $idx+1;
        }
      }
      print $out_fh "\n";
    }
    $cnt = $cnt + ($dependencies_offset - $scopes_pcs_offset);

    # Dependencies
    print $out_fh "Dependencies:\n";
    $idx = 0;
    my @dep = ();
    while ($idx < ($handler_table_offset - $dependencies_offset)) {
      $cnt_tmp = $cnt+$idx;
      my $c_value = unpack "x$cnt_tmp C", $bytes;
      push @dep, $c_value;
      my $output = sprintf("%02X", $c_value);
      $idx = $idx+1;
    }
    $cnt = $cnt + ($handler_table_offset - $dependencies_offset);
    $idx = 0;
    my $dep_c = 0;
    while ($idx < @dep) {
      my ($val, $new_idx) = read_b(\@dep, $idx);
      $idx = $new_idx;
      if ($val == 0) {
        print $out_fh "  end_marker\n";
        last;
      } else {
        #print $out_fh "  read_b: $val ";
        my $ctxk_bit = ($val & (1<<4));
        my ($dep_type, $stride) = parse_dep_type($val - $ctxk_bit);
        print $out_fh "  $dep_type ";
        my $skipj = -1;
        if ($ctxk_bit != 0) {
          $skipj = 0;
        }
        my $i = 0;
        while ($i < $stride) {
          if ($i == $skipj) {
            print $out_fh "0 ";
          } else {
            my ($v, $new_idx) = read_int(\@dep, $idx);
            $idx = $new_idx;
            print $out_fh "$v ";
          }
          $i = $i + 1;
        }
        print $out_fh "\n";
      }
    }

    # ExceptionHandlerTable
    $idx = 0;
    $cnt_tmp = $cnt+$idx;
    print $out_fh "ExceptionHandlerTable:\n";
    while ($idx < ($nul_chk_table_offset - $handler_table_offset)) {
      my $c_value = unpack "x$cnt_tmp I", $bytes;
      if ($c_value == 4294967295) {
        print $out_fh "  bci:-1 ";
      } else {
        print $out_fh "  bci:$c_value ";
      }
      $idx = $idx+4;
      $cnt_tmp = $cnt+$idx;
      $c_value = unpack "x$cnt_tmp I", $bytes;
      print $out_fh "pco:$c_value ";
      $idx = $idx+4;
      $cnt_tmp = $cnt+$idx;
      $c_value = unpack "x$cnt_tmp I", $bytes;
      print $out_fh "scope_depth:$c_value\n";
      $idx = $idx+4;
      $cnt_tmp = $cnt+$idx;
    }
    $cnt = $cnt + ($nul_chk_table_offset - $handler_table_offset);

    # ImplicitExceptionTable
    $idx = 0;
    print $out_fh "ImplicitExceptionTable:\n";
    if (($nmethod_end_offset - $nul_chk_table_offset) > 0) {
      my $imp_cnt = unpack "x$cnt I", $bytes;
      print $out_fh "  count:$imp_cnt\n";
      while ($idx < $imp_cnt) {
        $cnt_tmp = $cnt+4+$idx*8;
        my $c_value = unpack "x$cnt_tmp I", $bytes;
        print $out_fh "  exception-offset $c_value ";
        $cnt_tmp = $cnt+4+$idx*8+4;
        $c_value = unpack "x$cnt_tmp I", $bytes;
        print $out_fh "continue-offset $c_value\n";
        $idx = $idx+1;
      }
    }
    $cnt = $cnt + ($nmethod_end_offset - $nul_chk_table_offset);

    if ($cnt != $method_sz) {
      die "Method data format error!\n";
    }
  } else {
    die "Unexpected magic header:$magic\n";
  }
}

sub code_section
{
  my ($bytes, $cnt, $st) = @_;
  my $start = unpack "x$cnt Q", $bytes;
  $cnt = $cnt+8;
  print $out_fh "  $st._start: $start\n";
  my $end = unpack "x$cnt Q", $bytes;
  $cnt = $cnt+8;
  print $out_fh "  $st._end: $end\n";
  my $limit = unpack "x$cnt Q", $bytes;
  $cnt = $cnt+8;
  print $out_fh "  $st._limit: $limit\n";
  my $start_end_space = unpack "x$cnt I", $bytes;
  $cnt = $cnt+4;
  my $start_end_length = unpack "x$cnt I", $bytes;
  $cnt = $cnt+4;
  my $idx = 0;
  my $cnt_tmp;
  print $out_fh "  $st.start_end:\n";
  my $bin_data = substr $bytes, $cnt, $start_end_length;
  open(my $out, '>:raw', 'sample.bin') or die "Unable to open: $!";
  print $out $bin_data;
  close($out);
  my @disassemble = split /\n/, `objdump -mpowerpc:common64 -D -b binary sample.bin`;
  $idx = 6;
  while ($idx <= $#disassemble) {
    print $out_fh "$disassemble[$idx]\n";
    $idx = $idx+1;
  }
  print $out_fh "\n";
  `rm -f sample.bin`;
  $cnt = $cnt+$start_end_space;
  my $locs_start_locs_end_space = unpack "x$cnt I", $bytes;
  $cnt = $cnt+4;
  my $locs_start_locs_end_length = unpack "x$cnt I", $bytes;
  $cnt = $cnt+4;
  $idx = 0;
  print $out_fh "  $st.locs_start_locs_end:\n";
  my $reloc_ptr = 0;
  my $total_offset = 0;
  while ($reloc_ptr < $locs_start_locs_end_length) {
    my $cnt_tmp = $cnt+$reloc_ptr;
    my $value = unpack "x$cnt_tmp S", $bytes;
    my $type = $value >> $nontype_width;
    my $format = $format_mask & ($value>>$offset_width);
    if ($type <= 14) {
      my $type_str = sprintf "%-24s", int2reloc_type($type);
      my $offset = ($value & $offset_mask)*$offset_unit;
      $total_offset = $total_offset+$offset;
      my $t_offset_str = sprintf "%x", $total_offset;
      print $out_fh "    $type_str, format/$format, t_offset $t_offset_str\n";
    } elsif ($type == 15) {
      my $is_immediate_flag = $value & $datalen_tag;
      my $type_str = sprintf "%-24s", "data_prefix_tag";
      print $out_fh "    $type_str, format/$format, ";
      if ($is_immediate_flag == 0) {
        my $immediate = $value & $datalen_mask;
        print $out_fh "immediate:$immediate ";
      } else {
        my $datalen = $value & $datalen_mask;
        print $out_fh "datalen:$datalen ";
        my $datalen_cnt = $cnt+$reloc_ptr+$relocInfo_sz;
        $datalen = $datalen*2;
        $idx = 0;
        while ($idx < $datalen) {
          my $c_value = unpack "x$datalen_cnt C", $bytes;
          my $output = sprintf("%02x", $c_value);
          print $out_fh "$output";
          $idx = $idx+1;
          $datalen_cnt = $datalen_cnt+1;
        }
        $reloc_ptr = $reloc_ptr+$datalen;
      }
      print $out_fh "\n";
    } else {
      die "BUG";
    }
    $reloc_ptr = $reloc_ptr+$relocInfo_sz;
  }
  $cnt = $cnt+$locs_start_locs_end_space;
  my $locs_point_off = unpack "x$cnt i", $bytes;
  $cnt = $cnt+4;
  print $out_fh "  $st.locs_point_off: $locs_point_off\n";
  my $frozen = unpack "x$cnt C", $bytes;
  $cnt = $cnt+1;
  print $out_fh "  $st.frozen: $frozen\n";
  my $index = unpack "x$cnt C", $bytes;
  $cnt = $cnt+1;
  print $out_fh "  $st.index: $index\n\n";
  return $cnt;
}

sub int2reloc_type
{
  my ($id) = @_;
  
  if ($id == 0) {
    return "none";
  } elsif ($id == 1) {
    return "oop_type";
  } elsif ($id == 2) {
    return "virtual_call_type";
  } elsif ($id == 3) {
    return "opt_virtual_call_type";
  } elsif ($id == 4) {
    return "static_call_type";
  } elsif ($id == 5) {
    return "static_stub_type";
  } elsif ($id == 6) {
    return "runtime_call_type";
  } elsif ($id == 7) {
    return "external_word_type";
  } elsif ($id == 8) {
    return "internal_word_type";
  } elsif ($id == 9) {
    return "section_word_type";
  } elsif ($id == 10) {
    return "poll_type";
  } elsif ($id == 11) {
    return "poll_return_type";
  } elsif ($id == 12) {
    return "metadata_type";
  } elsif ($id == 13) {
    return "trampoline_stub_type";
  } elsif ($id == 14) {
    return "yet_unused_type_1";
  } elsif ($id == 15) {
    return "data_prefix_tag";
  } else {
    return "BUG";
  }
}

sub read_b
{
  my ($buffer, $position) = @_;
  return (@{$buffer}[$position], ($position+1));
}

sub read_int
{
  my ($buffer, $position) = @_;
  my ($b0, $new_position) = read_b($buffer, $position);
  if ($b0 < $L) {
    return ($b0, $new_position);
  } else {
    return read_int_mb($buffer, $new_position, $b0);
  }
}

sub read_int_mb
{
  my ($buffer, $position, $b0) = @_;
  my $sum = $b0;
  my $lg_H_i = $lg_H;
  my $i = 0;
  my $pos = $position-1;
  while (1) {
    $i = $i+1;
    my $b_i = @{$buffer}[$pos+$i];
    $sum = $sum + ($b_i << $lg_H_i);
    if (($b_i < $L) or ($i == $MAX_i)) {
      return ($sum, ($pos+$i+1));
    }
    $lg_H_i = $lg_H_i + $lg_H;
  }
}

sub read_bci
{
  my ($buffer, $position) = @_;
  my ($ret, $new_pos) = read_int($buffer, $position);
  $ret = $ret-1;
  return ($ret, $new_pos);
}

sub read_long
{
  my ($buffer, $position) = @_;
  my ($low, $high, $new_pos);
  ($low, $new_pos) = read_int($buffer, $position);
  $position = $new_pos;
  ($high, $new_pos) = read_int($buffer, $position);
  $position = $new_pos;
  my $full_long = ($high<<32)+$low;
  return ($full_long, $position);
}

sub read_double
{
  my ($buffer, $position) = @_;
  return read_long($buffer, $position);
}

sub parse_scope_value
{
  my ($buffer, $position) = @_;
  my @ret = ();
  my ($code, $val, $new_pos);

  ($code, $new_pos) = read_int($buffer, $position);
  $position = $new_pos;
  if ($code == $LOCATION_CODE) {
    ($val, $new_pos) = read_int($buffer, $position);
    push @ret, "LOC_C";
    #push @ret, $val;
    my $desc = "";
    my $type = $val & 0x0F;
    if ($type == 0) {
      $desc = $desc."invalid/";
    } elsif ($type == 1) {
      $desc = $desc."normal/";
    } elsif ($type == 2) {
      $desc = $desc."oop/";
    } elsif ($type == 3) {
      $desc = $desc."int_in_long/";
    } elsif ($type == 4) {
      $desc = $desc."lng/";
    } elsif ($type == 5) {
      $desc = $desc."float_in_dbl/";
    } elsif ($type == 6) {
      $desc = $desc."dbl/";
    } elsif ($type == 7) {
      $desc = $desc."addr/";
    } elsif ($type == 8) {
      $desc = $desc."narrowoop/";
    } else {
      $desc = $desc."NA/";
    }
    if ($val & 0x10) {
      $desc = $desc."in_register/";
    } else {
      $desc = $desc."on_stack/";
    }
    my $offset = $val>>5;
    if (($val & 0x10) == 0) {
      $offset = $offset<<2;
    }
    $desc = $desc."offset$offset";
    push @ret, $desc;
    push @ret, $new_pos;
    return @ret;
  } elsif ($code == $OBJECT_ID_CODE) {
    ($val, $new_pos) = read_int($buffer, $position);
    push @ret, "OBJ_ID_C";
    push @ret, $val;
    push @ret, $new_pos;
    return @ret;
  } elsif ($code == $OBJECT_CODE) {
    ($val, $new_pos) = read_int($buffer, $position);
    push @ret, "OBJ_C";
    push @ret, $val;
    my @tmp_ret = parse_scope_value($buffer, $new_pos); 
    my $idx = 0;
    while ($idx < @tmp_ret-1) {
      push @ret, $tmp_ret[$idx];
      $idx = $idx+1;
    }
    ($val, $new_pos) = read_int($buffer, $tmp_ret[@tmp_ret-1]);
    push @ret, "Count$val";
    my $count = $val;
    $idx = 0;
    while ($idx < $count) {
      @tmp_ret = ();
      @tmp_ret = parse_scope_value($buffer, $new_pos);
      my $idx2 = 0;
      while ($idx2 < @tmp_ret-1) {
        push @ret, $tmp_ret[$idx2];
        $idx2 = $idx2+1;
      }
      $new_pos = $tmp_ret[@tmp_ret-1];
      $idx = $idx+1;
    }
    push @ret, $new_pos;
    return @ret;
  } elsif ($code == $CONSTANT_INT_CODE) {
    ($val, $new_pos) = read_int($buffer, $position);
    push @ret, "CONST_I_C";
    push @ret, $val;
    push @ret, $new_pos;
    return @ret;
  } elsif ($code == $CONSTANT_LONG_CODE) {
    ($val, $new_pos) = read_long($buffer, $position);
    push @ret, "CONST_L_C";
    push @ret, $val;
    push @ret, $new_pos;
    return @ret;
  } elsif ($code == $CONSTANT_DOUBLE_CODE) {
    ($val, $new_pos) = read_double($buffer, $position);
    push @ret, "CONST_D_C";
    push @ret, $val;
    push @ret, $new_pos;
    return @ret;
  } elsif ($code == $CONSTANT_OOP_CODE) {
    ($val, $new_pos) = read_int($buffer, $position);
    push @ret, "CONST_O_C";
    push @ret, $val;
    push @ret, $new_pos;
    return @ret;
  }
  die "BUG unknown code: $code";
}

sub parse_monitor_value
{
  my ($buffer, $position) = @_;
  my @ret = ();
  my @parse_ret = ();
  my ($basic_lock, $eliminated, $new_pos);

  ($basic_lock, $new_pos) = read_int($buffer, $position);
  $position = $new_pos;
  push @parse_ret, "basic_lock$basic_lock";
  @ret = parse_scope_value($buffer, $position);
  my $idx = 0;
  while ($idx < @ret-1) {
    push @parse_ret, $ret[$idx];
    $idx = $idx+1;
  }
  $position = $ret[@ret-1];
  ($eliminated, $new_pos) = read_b($buffer, $position);
  push @parse_ret, "eliminated$eliminated";
  push @parse_ret, $new_pos;
  return @parse_ret;
}

sub parse_dep_type
{
  my ($code) = @_;
  if ($code == 1) {
    return ("evol_method", 1);
  } elsif ($code == 2) {
    return ("leaf_type", 1);
  } elsif ($code == 3) {
    return ("abstract_with_unique_concrete_subtype", 2);
  } elsif ($code == 4) {
    return ("abstract_with_no_concrete_subtype", 1);
  } elsif ($code == 5) {
    return ("concrete_with_no_concrete_subtype", 1);
  } elsif ($code == 6) {
    return ("unique_concrete_method", 2);
  } elsif ($code == 7) {
    return ("abstract_with_exclusive_concrete_subtypes_2", 3);
  } elsif ($code == 8) {
    return ("exclusive_concrete_methods_2", 3);
  } elsif ($code == 9) {
    return ("no_finalizable_subclasses", 1);
  } elsif ($code == 10) {
    return ("call_site_target_value", 2);
  } else {
    die "Unknown dep_type: $code!";
  }
}
